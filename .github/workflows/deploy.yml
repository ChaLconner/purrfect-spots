# ==============================================================================
# Purrfect Spots - Deployment Pipeline (Production)
# ==============================================================================
# Handles deployment to staging and production environments on Vercel
#
# Deployment Strategy:
# - Staging: Auto-deploy on push to 'dev' branch (after CI passes)
# - Production: Manual trigger or auto-deploy on push to 'main' branch
#
# Security:
# - All secrets accessed via env vars only, never in shell interpolation
# - All actions pinned to full SHA
# - Minimal permissions scope per job
#
# Prerequisites:
# - Configure repository secrets for each environment
# - Set up environment protection rules in GitHub Settings
# - Branch protection on 'main' must allow tag pushes from github-actions[bot]
# ==============================================================================

name: Deploy

on:
  # Trigger after CI/CD Pipeline completes successfully
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main, dev]

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      skip_health_check:
        description: "Skip health check after deployment"
        required: false
        type: boolean
        default: false

# FIX #7: cancel-in-progress is disabled for production (main branch)
# to prevent cancelling a live smoke-test or release-tag step mid-flight.
# Staging (dev branch) still cancels eagerly so only the latest commit deploys.
concurrency:
  group: deploy-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

# ==============================================================================
# PERMISSIONS - Principle of least privilege
# ==============================================================================
permissions:
  contents: read
  packages: write
  deployments: write
  id-token: write

jobs:
  # ============================================================================
  # DETERMINE DEPLOYMENT TARGET
  # ============================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.status == 'completed')
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}
      start_time: ${{ steps.timer.outputs.start_time }}
    steps:
      - name: Start Timer
        id: timer
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Checkout code
        # FIX #2: All actions pinned to full SHA â€” consistent with security policy
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4.2.2
        with:
          fetch-depth: 0

      # FIX #14: reliably detect the branch name when triggered by workflow_run.
      # github.ref in workflow_run is always the default branch (main).
      # We must use github.event.workflow_run.head_branch for the actual branch.
      - name: Determine environment
        id: set-env
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_ENV: ${{ inputs.environment }}
          HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
          REF_NAME: ${{ github.ref_name }}
        run: |
          # Use HEAD_BRANCH for workflow_run, otherwise use REF_NAME
          if [ "$EVENT_NAME" == "workflow_run" ]; then
            BRANCH_NAME="$HEAD_BRANCH"
          else
            BRANCH_NAME="$REF_NAME"
          fi

          echo "ðŸ” Detected branch: $BRANCH_NAME"

          if [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            echo "environment=${INPUT_ENV}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$BRANCH_NAME" == "main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$BRANCH_NAME" == "dev" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate required secrets
        id: validate-secrets
        env:
          # FIX #6: Read TARGET_ENV from the output of the previous step instead
          # of re-deriving it with duplicate if/elif logic.
          TARGET_ENV: ${{ steps.set-env.outputs.environment }}
          HAS_VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN != '' }}
          HAS_STAGING_API_URL: ${{ secrets.STAGING_API_URL != '' }}
          HAS_PROD_API_URL: ${{ secrets.PROD_API_URL != '' }}
          HAS_SUPABASE_URL: ${{ secrets.SUPABASE_URL != '' }}
          HAS_SUPABASE_KEY: ${{ secrets.SUPABASE_KEY != '' }}
        run: |
          echo "ðŸ”’ Validating required secrets..."

          # Validate secrets for staging
          if [ "$TARGET_ENV" == "staging" ]; then
            if [ "$HAS_VERCEL_TOKEN" != "true" ]; then
              echo "::error::VERCEL_TOKEN is required for staging deployment"
              exit 1
            fi
            if [ "$HAS_STAGING_API_URL" != "true" ]; then
              echo "::warning::STAGING_API_URL is not set. Deployment may fail."
            fi
          fi

          # Validate secrets for production
          if [ "$TARGET_ENV" == "production" ]; then
            if [ "$HAS_VERCEL_TOKEN" != "true" ]; then
              echo "::error::VERCEL_TOKEN is required for production deployment"
              exit 1
            fi
            if [ "$HAS_PROD_API_URL" != "true" ]; then
              echo "::error::PROD_API_URL is required for production deployment"
              exit 1
            fi
            if [ "$HAS_SUPABASE_URL" != "true" ]; then
              echo "::error::SUPABASE_URL is required for production deployment"
              exit 1
            fi
            if [ "$HAS_SUPABASE_KEY" != "true" ]; then
              echo "::error::SUPABASE_KEY is required for production deployment"
              exit 1
            fi
          fi

          echo "âœ… Secrets validation passed"

      - name: Generate version
        id: version
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)

          if [ "${{ steps.set-env.outputs.environment }}" == "production" ]; then
            TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            VERSION="${TAG}-${SHORT_SHA}"
          else
            VERSION="staging-${TIMESTAMP}-${SHORT_SHA}"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: ${VERSION}"

  # ============================================================================
  # STAGING - PARALLEL DEPLOYMENTS
  # ============================================================================
  staging-frontend:
    name: Staging - Frontend
    runs-on: ubuntu-latest
    needs: prepare
    if: ${{ needs.prepare.outputs.environment == 'staging' }}
    # FIX #13: Expose the preview URL as a job output so staging-verify
    # can include it in the Slack / Discord notification.
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
    environment:
      name: staging
      url: ${{ vars.STAGING_FRONTEND_URL }}
    steps:
      - name: Checkout code
        # FIX #2: Pinned to full SHA
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4.2.2

      - name: Setup Node.js
        # FIX #12: Pinned to full SHA
        uses: actions/setup-node@1d0ff469b25f0db13a21f291e044fc0397d12f6d # v4.2.0
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Authenticate Vercel
        run: vercel whoami --token="${{ secrets.VERCEL_TOKEN }}"

      - name: Cache API Client Node Modules
        # FIX #12: Pinned to full SHA
        uses: actions/cache@d4323d4dc3a886dc810163b75ebb7a4ea95d8a58 # v4.2.2
        with:
          path: api-client/node_modules
          key: ${{ runner.os }}-api-client-${{ hashFiles('api-client/package.json') }}

      - name: Validate API Client Generation
        run: |
          echo "ðŸ§ª Validating API Client Generation..."
          cd api-client
          [ -d node_modules ] || npm install --prefer-offline --no-audit
          npm run validate

      # FIX #5: Remove any stale .vercel directory before linking, matching the
      # pattern already used in staging-backend. Prevents wrong-project errors
      # if the repo happens to contain a committed .vercel folder.
      - name: Deploy Frontend to Vercel (Staging)
        id: deploy
        shell: bash
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          STAGING_API_URL: ${{ secrets.STAGING_API_URL }}
          GOOGLE_MAPS_API_KEY: ${{ secrets.GOOGLE_MAPS_API_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
        run: |
          # FIX #5: Purge any committed / cached .vercel config before linking
          rm -rf .vercel

          echo "ðŸš€ Linking and Pulling Frontend Config..."
          vercel link --yes --token="$VERCEL_TOKEN"
          vercel pull --yes --environment=preview --token="$VERCEL_TOKEN"

          # FIX #11: Replace '|| true' with an explicit warning so injection
          # failures are visible in the workflow log without failing the step.
          echo "ðŸ”§ Injecting environment variables..."
          echo "$STAGING_API_URL" | vercel env add VITE_API_BASE_URL preview \
            --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" \
            2>&1 || echo "::warning::Failed to inject VITE_API_BASE_URL â€” it may already exist with the correct value."

          # FIX #1: Secrets must never be expanded inside unquoted shell words.
          # Pass each variable through vercel env add (already done above for the
          # URL) or via quoted --build-env assignments. Every value is double-
          # quoted to survive spaces, dollar signs, and other special characters.
          BUILD_ENV_FLAGS="--build-env VITE_SUPABASE_URL=\"${SUPABASE_URL}\""
          BUILD_ENV_FLAGS="${BUILD_ENV_FLAGS} --build-env VITE_SUPABASE_ANON_KEY=\"${SUPABASE_KEY}\""
          [ -n "$STAGING_API_URL" ] && BUILD_ENV_FLAGS="${BUILD_ENV_FLAGS} --build-env VITE_API_BASE_URL=\"${STAGING_API_URL}\""
          [ -n "$GOOGLE_MAPS_API_KEY" ] && BUILD_ENV_FLAGS="${BUILD_ENV_FLAGS} --build-env VITE_GOOGLE_MAPS_API_KEY=\"${GOOGLE_MAPS_API_KEY}\""

          echo "ðŸš€ Deploying Frontend..."
          # FIX #13: Capture the deployment URL for downstream notification
          # Targeted frontend directory explicitly and removed eval for cleaner execution
          DEPLOY_OUTPUT=$(vercel deploy ./frontend \
            --yes \
            --token="$VERCEL_TOKEN" \
            $BUILD_ENV_FLAGS)
          URL=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[a-zA-Z0-9.-]+\.vercel\.app' | head -1)
          echo "deployment_url=${URL}" >> $GITHUB_OUTPUT
          echo "âœ… Deployed to: ${URL}"

  staging-backend:
    name: Staging - Backend
    runs-on: ubuntu-latest
    needs: prepare
    if: ${{ needs.prepare.outputs.environment == 'staging' }}
    environment:
      name: staging
    steps:
      - name: Checkout code
        # FIX #2: Pinned to full SHA
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4.2.2

      - name: Setup Node.js
        # FIX #12: Pinned to full SHA
        uses: actions/setup-node@1d0ff469b25f0db13a21f291e044fc0397d12f6d # v4.2.0
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Authenticate Vercel
        run: vercel whoami --token="${{ secrets.VERCEL_TOKEN }}"

      - name: Deploy Backend to Vercel (Staging)
        shell: bash
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
        run: |
          echo "ðŸš€ Linking and Pulling Backend Config..."
          rm -rf .vercel
          vercel link --yes --token="$VERCEL_TOKEN"
          vercel pull --yes --environment=preview --token="$VERCEL_TOKEN"

          # FIX #11: Warning on failure instead of silent '|| true'
          echo "ðŸ”§ Injecting environment variables..."
          echo "$SUPABASE_URL" | vercel env add SUPABASE_URL preview \
            --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" \
            2>&1 || echo "::warning::Failed to inject SUPABASE_URL â€” it may already exist with the correct value."
          echo "$SUPABASE_KEY" | vercel env add SUPABASE_KEY preview \
            --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" \
            2>&1 || echo "::warning::Failed to inject SUPABASE_KEY â€” it may already exist with the correct value."

          echo "ðŸš€ Deploying Backend..."
          vercel deploy ./backend \
            --yes \
            --token="$VERCEL_TOKEN"

  staging-verify:
    name: Staging - Verification
    runs-on: ubuntu-latest
    needs: [prepare, staging-frontend, staging-backend]
    if: ${{ always() && needs.prepare.outputs.environment == 'staging' }}
    steps:
      # FIX #8: Replace single curl with a retry loop.
      # Vercel preview deployments can take >10 s to cold-start; 5 Ã— 10 s
      # retries give a 50 s window before the health check is declared failed.
      - name: Staging Health Check
        if: inputs.skip_health_check != true && needs.staging-frontend.result == 'success' && needs.staging-backend.result == 'success'
        env:
          STAGING_API_URL: ${{ secrets.STAGING_API_URL }}
        run: |
          echo "ðŸ¥ Running staging health check..."
          MAX_ATTEMPTS=5
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i / $MAX_ATTEMPTS..."
            curl -sf --max-time 15 "${STAGING_API_URL}/health/ready" && {
              echo "âœ… Staging Backend is Healthy"
              exit 0
            }
            [ "$i" -lt "$MAX_ATTEMPTS" ] && echo "Not ready yet, retrying in 10s..." && sleep 10
          done
          echo "âŒ Staging Health Check Failed after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Notify Staging Result
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          FE_RESULT: ${{ needs.staging-frontend.result }}
          BE_RESULT: ${{ needs.staging-backend.result }}
          VERSION: ${{ needs.prepare.outputs.version }}
          # FIX #13: Frontend URL is now available from staging-frontend output
          FRONTEND_URL: ${{ needs.staging-frontend.outputs.deployment_url }}
        run: |
          if [ "$FE_RESULT" == "success" ] && [ "$BE_RESULT" == "success" ]; then
            TITLE="âœ… Staging Deployment Successful"
            COLOR_SLACK="good"
            COLOR_DISCORD=5763719
          else
            TITLE="âŒ Staging Deployment Failed"
            COLOR_SLACK="danger"
            COLOR_DISCORD=15548997
          fi

          [ -n "$SLACK_WEBHOOK_URL" ] && curl -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{\"text\": \"${TITLE}\", \"attachments\": [{\"color\": \"${COLOR_SLACK}\", \"fields\": [{\"title\": \"Environment\", \"value\": \"Staging\", \"short\": true}, {\"title\": \"Version\", \"value\": \"${VERSION}\", \"short\": true}, {\"title\": \"URL\", \"value\": \"${FRONTEND_URL}\", \"short\": false}]}]}" \
            2>/dev/null || true
          [ -n "$DISCORD_WEBHOOK_URL" ] && curl -X POST "$DISCORD_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{\"embeds\": [{\"title\": \"${TITLE}\", \"color\": ${COLOR_DISCORD}, \"fields\": [{\"name\": \"Environment\", \"value\": \"Staging\"}, {\"name\": \"Version\", \"value\": \"${VERSION}\"}, {\"name\": \"URL\", \"value\": \"${FRONTEND_URL}\"}]}]}" \
            2>/dev/null || true
          echo "Notifying: $TITLE"

  # ============================================================================
  # PRODUCTION - MODULAR FLOW
  # ============================================================================
  production-backup:
    name: Production - Backup
    runs-on: ubuntu-latest
    needs: prepare
    if: ${{ needs.prepare.outputs.environment == 'production' }}
    steps:
      - name: Pre-deployment backup
        env:
          BACKUP_WEBHOOK_URL: ${{ secrets.BACKUP_WEBHOOK_URL }}
          BACKUP_API_KEY: ${{ secrets.BACKUP_API_KEY }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "ðŸ’¾ Creating pre-deployment backup..."
          if [ -n "$BACKUP_WEBHOOK_URL" ]; then
            curl -X POST "$BACKUP_WEBHOOK_URL" \
              -H "Authorization: Bearer $BACKUP_API_KEY" \
              -H "Content-Type: application/json" \
              -d "{\"type\": \"pre-deployment\", \"version\": \"${VERSION}\"}"
          fi

  production-frontend:
    name: Production - Frontend
    runs-on: ubuntu-latest
    needs: [prepare, production-backup]
    if: ${{ needs.prepare.outputs.environment == 'production' }}
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
    environment:
      name: production
      url: https://purrfect-spots.vercel.app
    steps:
      - name: Checkout code
        # FIX #2: Pinned to full SHA
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4.2.2
      - name: Setup Node.js
        # FIX #12: Pinned to full SHA
        uses: actions/setup-node@1d0ff469b25f0db13a21f291e044fc0397d12f6d # v4.2.0
        with: { node-version: "20", cache: "npm" }
      - name: Install Vercel CLI
        run: npm install -g vercel@latest
      - name: Authenticate Vercel
        run: vercel whoami --token="${{ secrets.VERCEL_TOKEN }}"
      - id: deploy
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          PROD_API_URL: ${{ secrets.PROD_API_URL }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          GOOGLE_MAPS_API_KEY: ${{ secrets.GOOGLE_MAPS_API_KEY }}
        run: |
          # FIX #5: Purge stale .vercel config before linking
          rm -rf .vercel

          echo "ðŸš€ Linking and Pulling Frontend Production Config..."
          vercel link --yes --token="$VERCEL_TOKEN"
          vercel pull --yes --environment=production --token="$VERCEL_TOKEN"

          # FIX #11: Warning on failure instead of silent '|| true'
          echo "ðŸ”§ Injecting environment variables..."
          echo "$PROD_API_URL" | vercel env add VITE_API_BASE_URL production \
            --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" \
            2>&1 || echo "::warning::Failed to inject VITE_API_BASE_URL â€” it may already exist with the correct value."

          # FIX #1: All secret values are double-quoted to handle special characters
          VITE_FLAGS="--build-env VITE_SUPABASE_URL=\"${SUPABASE_URL}\" --build-env VITE_SUPABASE_ANON_KEY=\"${SUPABASE_KEY}\""
          [ -n "$PROD_API_URL" ] && VITE_FLAGS="${VITE_FLAGS} --build-env VITE_API_BASE_URL=\"${PROD_API_URL}\""
          [ -n "$GOOGLE_MAPS_API_KEY" ] && VITE_FLAGS="${VITE_FLAGS} --build-env VITE_GOOGLE_MAPS_API_KEY=\"${GOOGLE_MAPS_API_KEY}\""

          echo "ðŸš€ Triggering Vercel Production Deployment..."
          # Targeted frontend directory and removed invalid --project flag
          DEPLOY_OUTPUT=$(vercel deploy ./frontend --prod --yes --token="$VERCEL_TOKEN" $VITE_FLAGS)
          URL=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[a-zA-Z0-9.-]+\.vercel\.app' | head -1)
          echo "deployment_url=${URL}" >> $GITHUB_OUTPUT
          echo "âœ… Deployed to: ${URL}"

  production-backend:
    name: Production - Backend
    runs-on: ubuntu-latest
    needs: [prepare, production-backup]
    if: ${{ needs.prepare.outputs.environment == 'production' }}
    steps:
      - name: Checkout code
        # FIX #2: Pinned to full SHA
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4.2.2
      - name: Setup Node.js
        # FIX #12: Pinned to full SHA
        uses: actions/setup-node@1d0ff469b25f0db13a21f291e044fc0397d12f6d # v4.2.0
        with: { node-version: "20", cache: "npm" }
      - name: Install Vercel CLI
        run: npm install -g vercel@latest
      - name: Authenticate Vercel
        run: vercel whoami --token="${{ secrets.VERCEL_TOKEN }}"
      - name: Deploy Backend
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          # FIX #10: Backend explicitly uses VERCEL_BACKEND_PROJECT_ID, not the
          # shared VERCEL_PROJECT_ID, so the correct project is always targeted.
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
        run: |
          echo "ðŸš€ Linking and Pulling Backend Production Config..."
          rm -rf .vercel
          vercel link --yes --token="$VERCEL_TOKEN"
          vercel pull --yes --environment=production --token="$VERCEL_TOKEN"

          # FIX #11: Warning on failure instead of silent '|| true'
          echo "ðŸ”§ Injecting environment variables..."
          echo "$SUPABASE_URL" | vercel env add SUPABASE_URL production \
            --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" \
            2>&1 || echo "::warning::Failed to inject SUPABASE_URL â€” it may already exist with the correct value."
          echo "$SUPABASE_KEY" | vercel env add SUPABASE_KEY production \
            --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" \
            2>&1 || echo "::warning::Failed to inject SUPABASE_KEY â€” it may already exist with the correct value."

          echo "ðŸš€ Triggering Backend Deployment..."
          vercel deploy ./backend --prod --yes --token="$VERCEL_TOKEN"

  production-verify:
    name: Production - Verification
    runs-on: ubuntu-latest
    needs: [prepare, production-frontend, production-backend]
    if: ${{ always() && needs.prepare.outputs.environment == 'production' }}
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout code
        # Need repo access for tagging
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4.2.2
        with:
          fetch-depth: 0

      - name: Smoke Tests
        if: needs.production-frontend.result == 'success' && needs.production-backend.result == 'success'
        env:
          PROD_API_URL: ${{ secrets.PROD_API_URL }}
        run: |
          echo "ðŸ§ª Running Smoke Tests..."
          MAX_ATTEMPTS=5
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i / $MAX_ATTEMPTS..."
            curl -sf --max-time 15 "${PROD_API_URL}/health/ready" && {
              echo "âœ… Backend integration check passed"
              exit 0
            }
            [ "$i" -lt "$MAX_ATTEMPTS" ] && echo "Not ready yet, retrying in 15s..." && sleep 15
          done
          echo "âŒ Smoke test failed after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Create Release Tag
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "ðŸ·ï¸ Creating release tag..."

          TAG_NAME="release-${VERSION}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git tag -a "${TAG_NAME}" -m "Production release ${VERSION}"
          git push origin "${TAG_NAME}"

          gh release create "${TAG_NAME}" \
            --title "Release ${VERSION}" \
            --notes "Automated production release

          - Version: ${VERSION}
          - Deployed by: ${{ github.actor }}
          - Commit: ${{ github.sha }}" \
            --latest

          echo "âœ… Release tag ${TAG_NAME} created and pushed"

      - name: Rollback on Failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERSION: ${{ needs.prepare.outputs.version }}
          # FIX #10: Both project IDs are explicitly present so each rollback
          # targets the correct Vercel project independently.
          VERCEL_FRONTEND_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_BACKEND_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}
        run: |
          echo "ðŸ”„ Initiating rollback..."

          PREVIOUS_TAG=$(git describe --tags --abbrev=0 --exclude="release-${VERSION}" 2>/dev/null || echo "")

          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Rolling back to $PREVIOUS_TAG"

            # FIX #3: Each rollback now targets its own project explicitly via
            # VERCEL_PROJECT_ID env var instead of the unsupported --project flag.
            echo "Rolling back frontend..."
            VERCEL_PROJECT_ID="$VERCEL_FRONTEND_PROJECT_ID" vercel rollback \
              --yes \
              --token="$VERCEL_TOKEN" \
              || echo "::warning::Frontend rollback failed"

            if [ -n "$VERCEL_BACKEND_PROJECT_ID" ]; then
              echo "Rolling back backend..."
              VERCEL_PROJECT_ID="$VERCEL_BACKEND_PROJECT_ID" vercel rollback \
                --yes \
                --token="$VERCEL_TOKEN" \
                || echo "::warning::Backend rollback failed"
            fi

            echo "âœ… Rollback completed"
          else
            echo "::warning::No previous tag found for rollback â€“ this appears to be the first deployment."
            echo "â„¹ï¸ Manual intervention may be needed. Check the deployment dashboard."
          fi

      - name: Notify Deployment Result
        if: always()
        env:
          # FIX #4: Was incorrectly reading from steps.deploy-frontend (a step
          # that does not exist in this job). Now reads from the correct
          # needs.production-frontend job output.
          FRONTEND_URL: ${{ needs.production-frontend.outputs.deployment_url }}
          VERSION: ${{ needs.prepare.outputs.version }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          JOB_STATUS: ${{ job.status }}
        run: |
          if [ "$JOB_STATUS" == "success" ]; then
            echo "âœ… Production deployment successful!"
            echo "ðŸ”— URL: ${FRONTEND_URL}"
            echo "ðŸ“¦ Version: ${VERSION}"
            COLOR_SLACK="good"
            COLOR_DISCORD=5763719
            TITLE="âœ… Production Deployment Successful"
          else
            echo "âŒ Production deployment failed!"
            echo "ðŸ”„ Rollback initiated automatically."
            COLOR_SLACK="danger"
            COLOR_DISCORD=15548997
            TITLE="âŒ Production Deployment Failed - Rollback Initiated"
          fi

          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -X POST "$SLACK_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -d "{
                \"text\": \"${TITLE}\",
                \"attachments\": [{
                  \"color\": \"${COLOR_SLACK}\",
                  \"fields\": [
                    {\"title\": \"Environment\", \"value\": \"Production\", \"short\": true},
                    {\"title\": \"Version\", \"value\": \"${VERSION}\", \"short\": true},
                    {\"title\": \"URL\", \"value\": \"${FRONTEND_URL}\", \"short\": false},
                    {\"title\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                    {\"title\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"short\": false}
                  ]
                }]
              }" 2>/dev/null || echo "Slack notification failed"
          fi

          if [ -n "$DISCORD_WEBHOOK_URL" ]; then
            curl -X POST "$DISCORD_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -d "{
                \"embeds\": [{
                  \"title\": \"${TITLE}\",
                  \"color\": ${COLOR_DISCORD},
                  \"fields\": [
                    {\"name\": \"Environment\", \"value\": \"Production\", \"inline\": true},
                    {\"name\": \"Version\", \"value\": \"${VERSION}\", \"inline\": true},
                    {\"name\": \"URL\", \"value\": \"${FRONTEND_URL}\"},
                    {\"name\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                    {\"name\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}
                  ]
                }]
              }" 2>/dev/null || echo "Discord notification failed"
          fi

  # ============================================================================
  # DEPLOYMENT SUMMARY
  # FIX #9: summary no longer depends on both staging-verify AND production-verify.
  # Only the relevant verify job for the current environment is waited on, which
  # prevents a production run from blocking on a skipped staging job (and vice
  # versa). The 'always()' guard ensures the summary still runs on failures.
  # ============================================================================
  summary-staging:
    name: Deployment Summary (Staging)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [prepare, staging-verify]
    if: ${{ always() && needs.prepare.outputs.environment == 'staging' && needs.prepare.outputs.should_deploy == 'true' }}
    steps:
      - name: Create staging deployment summary
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          FRONTEND_URL: ${{ needs.staging-frontend.outputs.deployment_url }}
          STAGING_RESULT: ${{ needs.staging-verify.result }}
          START_TIME: ${{ needs.prepare.outputs.start_time }}
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | staging |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${VERSION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | ${FRONTEND_URL} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Staging Deployment" >> $GITHUB_STEP_SUMMARY
          STATUS="âŒ Failed"
          [ "${STAGING_RESULT}" == "success" ] && STATUS="âœ… Success"
          [ "${STAGING_RESULT}" == "skipped" ] && STATUS="â­ï¸ Skipped"
          echo "| Status | ${STATUS} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Deployment Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run ID**: \`${{ github.run_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ github.server_url }}/${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "$START_TIME" ] && [ "$START_TIME" != "null" ]; then
            END_TIME=$(date +%s)
            DURATION=$((END_TIME - START_TIME))
            if [ $DURATION -gt 0 ]; then
              MINUTES=$((DURATION / 60))
              SECONDS=$((DURATION % 60))
              echo "- **Deployment Duration**: ${MINUTES}m ${SECONDS}s" >> $GITHUB_STEP_SUMMARY
            fi
          fi

  summary-production:
    name: Deployment Summary (Production)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [prepare, production-verify]
    if: ${{ always() && needs.prepare.outputs.environment == 'production' && needs.prepare.outputs.should_deploy == 'true' }}
    steps:
      - name: Create production deployment summary
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          FRONTEND_URL: ${{ needs.production-frontend.outputs.deployment_url }}
          PRODUCTION_RESULT: ${{ needs.production-verify.result }}
          START_TIME: ${{ needs.prepare.outputs.start_time }}
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | production |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${VERSION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | ${FRONTEND_URL} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Production Deployment" >> $GITHUB_STEP_SUMMARY
          STATUS="âŒ Failed"
          [ "${PRODUCTION_RESULT}" == "success" ] && STATUS="âœ… Success"
          [ "${PRODUCTION_RESULT}" == "skipped" ] && STATUS="â­ï¸ Skipped"
          echo "| Status | ${STATUS} |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | ${FRONTEND_URL} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Deployment Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run ID**: \`${{ github.run_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ github.server_url }}/${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "$START_TIME" ] && [ "$START_TIME" != "null" ]; then
            END_TIME=$(date +%s)
            DURATION=$((END_TIME - START_TIME))
            if [ $DURATION -gt 0 ]; then
              MINUTES=$((DURATION / 60))
              SECONDS=$((DURATION % 60))
              echo "- **Deployment Duration**: ${MINUTES}m ${SECONDS}s" >> $GITHUB_STEP_SUMMARY
            fi
          fi
