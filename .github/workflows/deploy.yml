# ==============================================================================
# Purrfect Spots - Deployment Pipeline
# ==============================================================================
# Handles deployment to staging and production environments on Vercel
#
# Deployment Strategy:
# - Staging: Auto-deploy on push to 'dev' branch (after CI passes)
# - Production: Manual trigger or auto-deploy on push to 'main' branch
#
# Prerequisites:
# - Configure repository secrets for each environment
# - Set up environment protection rules in GitHub Settings
# ==============================================================================

name: Deploy

on:
  # Trigger after CI/CD Pipeline completes successfully
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main, dev]

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      skip_health_check:
        description: "Skip health check after deployment"
        required: false
        type: boolean
        default: false

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false # Don't cancel in-progress deployments

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  # SECURITY: Set VERCEL_TOKEN as environment variable to prevent CLI arguments
  VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}

# ==============================================================================
# PERMISSIONS - Principle of least privilege
# ==============================================================================
permissions:
  contents: read
  packages: write
  deployments: write
  id-token: write # For OIDC authentication
  # SECURITY: Limit write permissions to only necessary scopes
  pull-requests: write # For status checks

jobs:
  # ============================================================================
  # DETERMINE DEPLOYMENT TARGET
  # ============================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Only run if CI passed (for workflow_run) or always (for workflow_dispatch)
    # Added additional check to ensure workflow_run was successful
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.status == 'completed')
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}
      start_time: ${{ steps.timer.outputs.start_time }}
    steps:
      - name: Start Timer
        id: timer
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Checkout code
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4.2.2
        with:
          fetch-depth: 0

      - name: Validate required secrets
        id: validate-secrets
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF: ${{ github.ref }}
          INPUT_ENV: ${{ inputs.environment }}
        run: |
          echo "ðŸ”’ Validating required secrets..."
          
          # Check for required secrets based on environment
          if [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            INPUT_ENV="$INPUT_ENV"
          else
            if [ "$REF" == "refs/heads/main" ]; then
              INPUT_ENV="production"
            elif [ "$REF" == "refs/heads/dev" ]; then
              INPUT_ENV="staging"
            else
              INPUT_ENV="none"
            fi
          fi
          
          # Validate secrets for staging
          if [ "$INPUT_ENV" == "staging" ]; then
            if [ -z "${{ secrets.VERCEL_TOKEN }}" ]; then
              echo "::error::VERCEL_TOKEN is required for staging deployment"
              exit 1
            fi
            if [ -z "${{ secrets.STAGING_API_URL }}" ]; then
              echo "::warning::STAGING_API_URL is not set. Deployment may fail."
            fi
          fi
          
          # Validate secrets for production
          if [ "$INPUT_ENV" == "production" ]; then
            if [ -z "${{ secrets.VERCEL_TOKEN }}" ]; then
              echo "::error::VERCEL_TOKEN is required for production deployment"
              exit 1
            fi
            if [ -z "${{ secrets.PROD_API_URL }}" ]; then
              echo "::error::PROD_API_URL is required for production deployment"
              exit 1
            fi
            if [ -z "${{ secrets.SUPABASE_URL }}" ]; then
              echo "::error::SUPABASE_URL is required for production deployment"
              exit 1
            fi
            if [ -z "${{ secrets.SUPABASE_KEY }}" ]; then
              echo "::error::SUPABASE_KEY is required for production deployment"
              exit 1
            fi
          fi
          
          echo "âœ… Secrets validation passed"

      - name: Determine environment
        id: set-env
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF: ${{ github.ref }}
          INPUT_ENV: ${{ inputs.environment }}
        run: |
          if [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            echo "environment=${INPUT_ENV}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$REF" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$REF" == "refs/heads/dev" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate version
        id: version
        run: |
          # Generate version based on git info
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)

          if [ "${{ steps.set-env.outputs.environment }}" == "production" ]; then
            # For production, try to use tag or generate semver-like version
            TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            VERSION="${TAG}-${SHORT_SHA}"
          else
            # For staging, use timestamp-based version
            VERSION="staging-${TIMESTAMP}-${SHORT_SHA}"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: ${VERSION}"

  # ============================================================================
  # DEPLOY TO STAGING
  # ============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: prepare
    if: needs.prepare.outputs.environment == 'staging'
    environment:
      name: staging
      url: ${{ vars.STAGING_FRONTEND_URL }}
      # Optional: Add protection rules for staging if needed
    steps:
      - name: Checkout code
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4

      - name: Validate API Client Generation
        run: |
          echo "ðŸ§ª Validating API Client Generation..."
          cd api-client
          npm ci --prefer-offline --no-audit
          npm run validate

      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4
        with:
          node-version: "20"

      - name: Deploy Frontend to Vercel (Staging)
        shell: bash
        run: |
          echo "ðŸš€ Deploying Frontend to Vercel Staging..."
          cd frontend

          # Link to Vercel project
          npx vercel link --yes --token="${{ secrets.VERCEL_TOKEN }}" --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed"; exit 1; }

          # Inject Env Vars for Staging (using --yes to avoid interactive prompts)
          # SECURITY: Use environment variables instead of command-line arguments to prevent secret leakage
          echo "ðŸ”§ Setting environment variables..."
          # Set environment variable for Vercel CLI to read from
          export VERCEL_TOKEN="${{ secrets.VERCEL_TOKEN }}"
          
          # Use Vercel CLI's --file flag to read from file instead of command-line arguments
          # This prevents secrets from appearing in logs or process lists
          echo "${{ secrets.STAGING_API_URL }}" > /tmp/staging_api_url.txt
          npx vercel env add VITE_API_BASE_URL preview --force --yes --file=/tmp/staging_api_url.txt 2>/dev/null || true
          rm -f /tmp/staging_api_url.txt
          
          if [ -n "${{ secrets.GOOGLE_MAPS_API_KEY }}" ]; then
            echo "${{ secrets.GOOGLE_MAPS_API_KEY }}" > /tmp/google_maps_key.txt
            npx vercel env add VITE_GOOGLE_MAPS_API_KEY preview --force --yes --file=/tmp/google_maps_key.txt 2>/dev/null || true
            rm -f /tmp/google_maps_key.txt
          fi
          echo "âœ… Environment variables configured"

          # Deploy to Vercel (server-side build)
          npx vercel deploy --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Deploy Backend to Vercel (Staging)
        shell: bash
        run: |
          echo "ðŸš€ Deploying Backend to Vercel Staging..."

          if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
            echo "::warning::VERCEL_BACKEND_PROJECT_ID secret is missing! Skipping backend deployment."
            exit 0
          fi

          cd backend

          # Link to Vercel project
          npx vercel link --yes --token="${{ secrets.VERCEL_TOKEN }}" --project "$VERCEL_BACKEND_PROJECT_ID" || { echo "::error::Vercel link failed for backend"; exit 1; }

          # Inject Env Vars for Staging (using --yes to avoid interactive prompts)
          # SECURITY: Use environment variables instead of command-line arguments to prevent secret leakage
          echo "ðŸ”§ Setting environment variables..."
          export VERCEL_TOKEN="${{ secrets.VERCEL_TOKEN }}"
          
          echo "${{ secrets.SUPABASE_URL }}" > /tmp/supabase_url.txt
          npx vercel env add SUPABASE_URL preview --force --yes --file=/tmp/supabase_url.txt 2>/dev/null || true
          rm -f /tmp/supabase_url.txt
          
          echo "${{ secrets.SUPABASE_KEY }}" > /tmp/supabase_key.txt
          npx vercel env add SUPABASE_KEY preview --force --yes --file=/tmp/supabase_key.txt 2>/dev/null || true
          rm -f /tmp/supabase_key.txt
          
          if [ -n "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
            echo "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" > /tmp/supabase_service_role_key.txt
            npx vercel env add SUPABASE_SERVICE_ROLE_KEY preview --force --yes --file=/tmp/supabase_service_role_key.txt 2>/dev/null || true
            rm -f /tmp/supabase_service_role_key.txt
          fi
          echo "âœ… Environment variables configured"

          # Deploy to Staging (server-side build)
          npx vercel deploy --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}

      - name: Health Check
        if: ${{ inputs.skip_health_check != true }}
        run: |
          echo "ðŸ¥ Running health check..."

          # Wait for deployment to propagate
          echo "Waiting 10 seconds for service startup..."
          sleep 10

          # Health check with retries
          MAX_RETRIES=20
          RETRY_DELAY=10

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            # Check backend health
            if curl -sf --max-time 10 "${{ secrets.STAGING_API_URL }}/health/ready" > /dev/null 2>&1; then
              echo "âœ… Backend readiness check passed!"
              BACKEND_OK=true
              break
            else
              echo "Backend not ready yet, retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done

          if [ "$BACKEND_OK" != "true" ]; then
             # Don't fail the pipeline if backend secret was missing (optional deployment)
             if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
                echo "âš ï¸ Backend check failed but VERCEL_BACKEND_PROJECT_ID was missing, so this is expected."
             else
                echo "âŒ Backend health check failed after $MAX_RETRIES attempts"
                exit 1
             fi
          fi

          echo "âœ… All health checks passed!"

      - name: Notify Deployment Success
        if: success()
        run: |
          echo "âœ… Staging deployment successful!"
          echo "ðŸ”— Frontend URL: ${{ secrets.STAGING_FRONTEND_URL }}"
          echo "ðŸ”— Backend URL: ${{ secrets.STAGING_API_URL }}"
          echo "ðŸ“¦ Version: ${{ needs.prepare.outputs.version }}"

      - name: Send Success Notification (Staging)
        if: success()
        run: |
          # Send notification to Slack/Discord if configured
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "text": "âœ… Staging Deployment Successful",
                "attachments": [{
                  "color": "good",
                  "fields": [
                    {"title": "Environment", "value": "Staging", "short": true},
                    {"title": "Version", "value": "${{ needs.prepare.outputs.version }}", "short": true},
                    {"title": "Frontend URL", "value": "${{ secrets.STAGING_FRONTEND_URL }}", "short": false},
                    {"title": "Backend URL", "value": "${{ secrets.STAGING_API_URL }}", "short": false},
                    {"title": "Deployed by", "value": "${{ github.actor }}", "short": true}
                  ]
                }]
              }' 2>/dev/null || echo "Slack notification failed"
          fi
          
          # Send notification to Discord if configured
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "embeds": [{
                  "title": "âœ… Staging Deployment Successful",
                  "color": 5763719,
                  "fields": [
                    {"name": "Environment", "value": "Staging", "inline": true},
                    {"name": "Version", "value": "${{ needs.prepare.outputs.version }}", "inline": true},
                    {"name": "Frontend URL", "value": "${{ secrets.STAGING_FRONTEND_URL }}"},
                    {"name": "Backend URL", "value": "${{ secrets.STAGING_API_URL }}"},
                    {"name": "Deployed by", "value": "${{ github.actor }}", "inline": true}
                  ]
                }]
              }' 2>/dev/null || echo "Discord notification failed"
          fi

      - name: Notify Deployment Failure
        if: failure()
        run: |
          echo "âŒ Staging deployment failed!"
          echo "Please check the logs for details."

      - name: Send Failure Notification (Staging)
        if: failure()
        run: |
          # Send notification to Slack/Discord if configured
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "text": "âŒ Staging Deployment Failed",
                "attachments": [{
                  "color": "danger",
                  "fields": [
                    {"title": "Environment", "value": "Staging", "short": true},
                    {"title": "Version", "value": "${{ needs.prepare.outputs.version }}", "short": true},
                    {"title": "Deployed by", "value": "${{ github.actor }}", "short": true},
                    {"title": "Workflow Run", "value": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}", "short": false}
                  ]
                }]
              }' 2>/dev/null || echo "Slack notification failed"
          fi
          
          # Send notification to Discord if configured
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "embeds": [{
                  "title": "âŒ Staging Deployment Failed",
                  "color": 15548997,
                  "fields": [
                    {"name": "Environment", "value": "Staging", "inline": true},
                    {"name": "Version", "value": "${{ needs.prepare.outputs.version }}", "inline": true},
                    {"name": "Deployed by", "value": "${{ github.actor }}", "inline": true},
                    {"name": "Workflow Run", "value": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"}
                  ]
                }]
              }' 2>/dev/null || echo "Discord notification failed"
          fi

  # ============================================================================
  # DEPLOY TO PRODUCTION
  # ============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: prepare
    outputs:
      frontend_url: ${{ steps.deploy-frontend.outputs.deployment_url }}
    if: needs.prepare.outputs.environment == 'production'
    environment:
      name: production
      url: https://purrfect-spots.vercel.app
      # Require manual approval for production deployments
      # Configure in GitHub Settings > Environments > production > Protection rules
    steps:
      - name: Checkout code
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4

      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4
        with:
          node-version: "20"

      - name: Pre-deployment backup
        run: |
          echo "ðŸ’¾ Creating pre-deployment backup..."

          # Trigger database backup via Supabase API or custom backup service
          if [ -n "${{ secrets.BACKUP_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.BACKUP_WEBHOOK_URL }}" \
              -H "Authorization: Bearer ${{ secrets.BACKUP_API_KEY }}" \
              -H "Content-Type: application/json" \
              -d '{"type": "pre-deployment", "version": "${{ needs.prepare.outputs.version }}"}'
            echo "Backup triggered successfully"
          else
            echo "::warning::No backup webhook configured. Skipping backup."
          fi

      - name: Deploy Frontend to Vercel (Production)
        id: deploy-frontend
        shell: bash
        run: |
          echo "ðŸš€ Deploying Frontend to Vercel Production..."

          # Check Secrets presence
          if [ -z "${{ secrets.VERCEL_TOKEN }}" ]; then
            echo "::error::VERCEL_TOKEN is not set"
            exit 1
          fi
          if [ -z "$VERCEL_ORG_ID" ]; then
            echo "::error::VERCEL_ORG_ID is not set"
            exit 1
          fi
          if [ -z "$VERCEL_PROJECT_ID" ]; then
             echo "::error::VERCEL_PROJECT_ID is not set"
             exit 1
          fi

          cd frontend

          # Link to Vercel project (creates .vercel folder)
          echo "ðŸ”— Linking to Vercel project..."
          npx vercel link --yes --token="${{ secrets.VERCEL_TOKEN }}" --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed"; exit 1; }

          # Inject Env Vars for Production (using --yes to avoid interactive prompts)
          # SECURITY: Use environment variables instead of command-line arguments to prevent secret leakage
          echo "ðŸ”§ Injecting environment variables..."
          export VERCEL_TOKEN="${{ secrets.VERCEL_TOKEN }}"
          
          echo "${{ secrets.PROD_API_URL }}" > /tmp/prod_api_url.txt
          npx vercel env add VITE_API_BASE_URL production --force --yes --file=/tmp/prod_api_url.txt 2>/dev/null || true
          rm -f /tmp/prod_api_url.txt
          
          if [ -n "${{ secrets.GOOGLE_MAPS_API_KEY }}" ]; then
            echo "${{ secrets.GOOGLE_MAPS_API_KEY }}" > /tmp/google_maps_key.txt
            npx vercel env add VITE_GOOGLE_MAPS_API_KEY production --force --yes --file=/tmp/google_maps_key.txt 2>/dev/null || true
            rm -f /tmp/google_maps_key.txt
          fi
          echo "âœ… Environment variables configured"

          # Deploy to Vercel (server-side build)
          echo "ðŸš€ Triggering Vercel User Deployment..."

          DEPLOY_OUTPUT=$(npx vercel deploy --prod --yes)
          DEPLOY_EXIT_CODE=$?

          if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
            echo "::error::Vercel deployment failed"
            echo "$DEPLOY_OUTPUT"
            exit $DEPLOY_EXIT_CODE
          fi

          deployment_url=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[a-zA-Z0-9.-]+\.vercel\.app' | head -1)

          if [ -z "$deployment_url" ]; then
            echo "::error::Deployment succeeded but no URL found"
            echo "$DEPLOY_OUTPUT"
            exit 1
          fi

          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
          echo "âœ… Deployed to: $deployment_url"
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Deploy Backend to Vercel (Production)
        shell: bash
        run: |
          echo "ðŸš€ Deploying Backend to Vercel Production..."

          if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
            echo "::error::VERCEL_BACKEND_PROJECT_ID secret is missing! Cannot deploy backend to Production."
            exit 1
          fi

          if [ -z "$VERCEL_ORG_ID" ]; then
             echo "::error::VERCEL_ORG_ID is not set (Backend)"
             exit 1
          fi

          cd backend

          # Link to Vercel project
          echo "ðŸ”— Linking Backend to Vercel..."
          npx vercel link --yes --token="${{ secrets.VERCEL_TOKEN }}" --project "$VERCEL_BACKEND_PROJECT_ID" || { echo "::error::Vercel link failed for backend"; exit 1; }

          # Inject Env Vars for Production (using --yes to avoid interactive prompts)
          # SECURITY: Use environment variables instead of command-line arguments to prevent secret leakage
          echo "ðŸ”§ Injecting environment variables..."
          export VERCEL_TOKEN="${{ secrets.VERCEL_TOKEN }}"
          
          echo "${{ secrets.SUPABASE_URL }}" > /tmp/supabase_url.txt
          npx vercel env add SUPABASE_URL production --force --yes --file=/tmp/supabase_url.txt 2>/dev/null || true
          rm -f /tmp/supabase_url.txt
          
          echo "${{ secrets.SUPABASE_KEY }}" > /tmp/supabase_key.txt
          npx vercel env add SUPABASE_KEY production --force --yes --file=/tmp/supabase_key.txt 2>/dev/null || true
          rm -f /tmp/supabase_key.txt
          
          if [ -n "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
            echo "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" > /tmp/supabase_service_role_key.txt
            npx vercel env add SUPABASE_SERVICE_ROLE_KEY production --force --yes --file=/tmp/supabase_service_role_key.txt 2>/dev/null || true
            rm -f /tmp/supabase_service_role_key.txt
          fi
          # Also inject JWT_SECRET if available (Required by config.py)
          if [ -n "${{ secrets.JWT_SECRET }}" ]; then
            echo "${{ secrets.JWT_SECRET }}" > /tmp/jwt_secret.txt
            npx vercel env add JWT_SECRET production --force --yes --file=/tmp/jwt_secret.txt 2>/dev/null || true
            rm -f /tmp/jwt_secret.txt
          fi
          echo "âœ… Environment variables configured"

          # Deploy to Production (server-side build)
          echo "ðŸš€ Triggering Backend Deployment..."
          npx vercel deploy --prod --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}

      - name: Health Check
        if: ${{ inputs.skip_health_check != true }}
        run: |
          echo "ðŸ¥ Running production health check..."

          # Wait for deployment to propagate
          echo "Waiting 15 seconds for service startup..."
          sleep 15

          # Health check with retries (more attempts for production)
          MAX_RETRIES=30
          RETRY_DELAY=10

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            # Check backend health
            if curl -sf --max-time 15 "${{ secrets.PROD_API_URL }}/health/ready" > /dev/null 2>&1; then
              echo "âœ… Backend readiness check passed!"
              
              # Check frontend
              # Use captured URL from deployment step
              FRONTEND_URL="${{ steps.deploy-frontend.outputs.deployment_url }}"
              if curl -sf --max-time 15 "$FRONTEND_URL" > /dev/null 2>&1; then
                echo "âœ… Frontend health check passed!"
                ALL_OK=true
                break
              fi
            fi
            
            echo "Services not ready yet, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done

          if [ "$ALL_OK" != "true" ]; then
            if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
               echo "âš ï¸ VERCEL_BACKEND_PROJECT_ID missing, so backend might not have deployed. Skipping failure."
            else
               echo "âŒ Production health check failed after $MAX_RETRIES attempts"
               echo "::error::Consider rolling back to previous version"
               exit 1
            fi
          fi

          echo "âœ… All production health checks passed!"

      - name: Install jq for JSON parsing
        run: |
          echo "ðŸ”§ Installing jq for JSON parsing..."
          sudo apt-get update && sudo apt-get install -y jq

      - name: Smoke Tests
        run: |
          echo "ðŸ§ª Running smoke tests..."

          # Critical API endpoints smoke test
          echo "Testing critical endpoints..."

          # Test health endpoint
          curl -sf "${{ secrets.PROD_API_URL }}/health/dependencies" | jq . || echo "Dependency health check"

          # Test public endpoints (no auth required)
          curl -sf "${{ secrets.PROD_API_URL }}/api/v1/spots?limit=1" > /dev/null && echo "âœ… Spots API OK" || echo "::warning::Spots API check failed"

          # CORS Smoke Test (Frontend -> Backend connectivity check)
          # Use captured URL from deployment step
          FRONTEND_URL="${{ steps.deploy-frontend.outputs.deployment_url }}"
          if [ -n "$FRONTEND_URL" ]; then
            echo "Testing CORS connectivity from $FRONTEND_URL to ${{ secrets.PROD_API_URL }}..."
            
            # Simulated CORS preflight/request check
            CORS_STATUS=$(curl -s -I -H "Origin: $FRONTEND_URL" -H "Access-Control-Request-Method: GET" "${{ secrets.PROD_API_URL }}/health/ready" | grep -i "Access-Control-Allow-Origin" || echo "MISSING")
            
            if [[ "$CORS_STATUS" == *"MISSING"* ]]; then
               echo "::warning::âš ï¸ CORS headers missing! Frontend may not be able to talk to Backend."
            else
               echo "âœ… CORS Check Passed: $CORS_STATUS"
            fi
          else
            echo "::warning::Frontend URL not found, skipping CORS check."
          fi

          echo "âœ… Smoke tests completed!"

      - name: Create Release Tag
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ·ï¸ Creating release tag..."

          VERSION="${{ needs.prepare.outputs.version }}"
          TAG_NAME="release-${VERSION}"

          # Validate version format
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+-[a-f0-9]+$ ]] && [[ ! "$VERSION" =~ ^staging-[0-9]{14}-[a-f0-9]+$ ]]; then
            echo "::warning::Version format may be invalid: $VERSION"
          fi

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create and push tag
          git tag -a "${TAG_NAME}" -m "Production release ${VERSION}"
          git push origin "${TAG_NAME}"

          # Create GitHub Release
          gh release create "${TAG_NAME}" \
            --title "Release ${VERSION}" \
            --notes "Automated production release\n\n- Version: ${VERSION}\n- Deployed by: ${{ github.actor }}\n- Commit: ${{ github.sha }}" \
            --latest

          echo "âœ… Release tag ${TAG_NAME} created and pushed"

      - name: Notify Deployment Success
        if: success()
        run: |
          echo "âœ… Production deployment successful!"
          echo "ðŸ”— URL: ${{ steps.deploy-frontend.outputs.deployment_url }}"
          echo "ðŸ“¦ Version: ${{ needs.prepare.outputs.version }}"

      - name: Send Success Notification (Production)
        if: success()
        run: |
          # Send notification to Slack/Discord if configured
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "text": "âœ… Production Deployment Successful",
                "attachments": [{
                  "color": "good",
                  "fields": [
                    {"title": "Environment", "value": "Production", "short": true},
                    {"title": "Version", "value": "${{ needs.prepare.outputs.version }}", "short": true},
                    {"title": "URL", "value": "${{ steps.deploy-frontend.outputs.deployment_url }}", "short": false},
                    {"title": "Deployed by", "value": "${{ github.actor }}", "short": true},
                    {"title": "Commit", "value": "${{ github.sha }}", "short": true}
                  ]
                }]
              }' 2>/dev/null || echo "Slack notification failed"
          fi
          
          # Send notification to Discord if configured
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "embeds": [{
                  "title": "âœ… Production Deployment Successful",
                  "color": 5763719,
                  "fields": [
                    {"name": "Environment", "value": "Production", "inline": true},
                    {"name": "Version", "value": "${{ needs.prepare.outputs.version }}", "inline": true},
                    {"name": "URL", "value": "${{ steps.deploy-frontend.outputs.deployment_url }}"},
                    {"name": "Deployed by", "value": "${{ github.actor }}", "inline": true},
                    {"name": "Commit", "value": "${{ github.sha }}", "inline": true}
                  ]
                }]
              }' 2>/dev/null || echo "Discord notification failed"
          fi

      - name: Rollback on Failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ”„ Initiating rollback..."
          
          # Get previous successful deployment from GitHub
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 --exclude="release-${{ needs.prepare.outputs.version }}" 2>/dev/null || echo "")
          
          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Rolling back to $PREVIOUS_TAG"
            
            # Rollback frontend
            cd frontend
            npx vercel rollback --token=${{ secrets.VERCEL_TOKEN }} --yes || echo "::warning::Frontend rollback failed"
            
            # Rollback backend if configured
            if [ -n "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
              cd ../backend
              npx vercel rollback --token=${{ secrets.VERCEL_TOKEN }} --yes || echo "::warning::Backend rollback failed"
            fi
            
            echo "âœ… Rollback completed"
          else
            echo "::warning::No previous tag found for rollback"
          fi
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_BACKEND_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}

      - name: Notify Deployment Failure
        if: failure()
        run: |
          echo "âŒ Production deployment failed!"
          echo "ðŸ”„ Rollback initiated automatically."

      - name: Send Failure Notification (Production)
        if: failure()
        run: |
          # Send notification to Slack/Discord if configured
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "text": "âŒ Production Deployment Failed - Rollback Initiated",
                "attachments": [{
                  "color": "danger",
                  "fields": [
                    {"title": "Environment", "value": "Production", "short": true},
                    {"title": "Version", "value": "${{ needs.prepare.outputs.version }}", "short": true},
                    {"title": "Deployed by", "value": "${{ github.actor }}", "short": true},
                    {"title": "Workflow Run", "value": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}", "short": false}
                  ]
                }]
              }' 2>/dev/null || echo "Slack notification failed"
          fi
          
          # Send notification to Discord if configured
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "embeds": [{
                  "title": "âŒ Production Deployment Failed - Rollback Initiated",
                  "color": 15548997,
                  "fields": [
                    {"name": "Environment", "value": "Production", "inline": true},
                    {"name": "Version", "value": "${{ needs.prepare.outputs.version }}", "inline": true},
                    {"name": "Deployed by", "value": "${{ github.actor }}", "inline": true},
                    {"name": "Workflow Run", "value": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"}
                  ]
                }]
              }' 2>/dev/null || echo "Discord notification failed"
          fi

  # ============================================================================
  # DEPLOYMENT SUMMARY
  # ============================================================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [prepare, deploy-staging, deploy-production]
    if: always() && needs.prepare.outputs.should_deploy == 'true'
    steps:
      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.prepare.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${{ needs.prepare.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | ${{ needs.deploy-production.outputs.frontend_url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Started At | ${{ github.event.head_commit.timestamp }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.prepare.outputs.environment }}" == "staging" ]; then
            echo "### Staging Deployment" >> $GITHUB_STEP_SUMMARY
            echo "| Status | ${{ needs.deploy-staging.result == 'success' && 'âœ… Success' || needs.deploy-staging.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
            echo "| URL | ${{ secrets.STAGING_FRONTEND_URL }} |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            echo "### Production Deployment" >> $GITHUB_STEP_SUMMARY
            echo "| Status | ${{ needs.deploy-production.result == 'success' && 'âœ… Success' || needs.deploy-production.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
            echo "| URL | ${{ needs.deploy-production.outputs.frontend_url }} |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Deployment Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run ID**: \`${{ github.run_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run Number**: \`${{ github.run_number }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ github.server_url }}/${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Calculate deployment duration
          START_TIME="${{ needs.prepare.outputs.start_time }}"
          # Fallback if start_time is missing (e.g. if we didn't run the step)
          if [ -z "$START_TIME" ] || [ "$START_TIME" == "null" ]; then
             START_TIME=$(date -d "${{ github.event.head_commit.timestamp }}" +%s 2>/dev/null || echo 0)
          fi

          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          if [ $DURATION -gt 0 ]; then
            MINUTES=$((DURATION / 60))
            SECONDS=$((DURATION % 60))
            echo "- **Deployment Duration**: ${MINUTES}m ${SECONDS}s" >> $GITHUB_STEP_SUMMARY
          fi
