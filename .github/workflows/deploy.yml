# ==============================================================================
# Purrfect Spots - Deployment Pipeline
# ==============================================================================
# Handles deployment to staging and production environments on Vercel
# 
# Deployment Strategy:
# - Staging: Auto-deploy on push to 'dev' branch (after CI passes)
# - Production: Manual trigger or auto-deploy on push to 'main' branch
#
# Prerequisites:
# - Configure repository secrets for each environment
# - Set up environment protection rules in GitHub Settings
# ==============================================================================

name: Deploy

on:
  # Trigger after CI/CD Pipeline completes successfully
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main, dev]
  
  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      skip_health_check:
        description: 'Skip health check after deployment'
        required: false
        type: boolean
        default: false

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel in-progress deployments

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# ==============================================================================
# PERMISSIONS
# ==============================================================================
permissions:
  contents: read
  packages: write
  deployments: write
  id-token: write  # For OIDC authentication

jobs:
  # ============================================================================
  # DETERMINE DEPLOYMENT TARGET
  # ============================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    # Only run if CI passed (for workflow_run) or always (for workflow_dispatch)
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/dev" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate version
        id: version
        run: |
          # Generate version based on git info
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          
          if [ "${{ steps.set-env.outputs.environment }}" == "production" ]; then
            # For production, try to use tag or generate semver-like version
            TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            VERSION="${TAG}-${SHORT_SHA}"
          else
            # For staging, use timestamp-based version
            VERSION="staging-${TIMESTAMP}-${SHORT_SHA}"
          fi
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: ${VERSION}"

  # ============================================================================
  # DEPLOY TO STAGING
  # ============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.purrfect-spots.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Deploy Frontend to Vercel (Staging)
        shell: bash
        run: |
          echo "ðŸš€ Deploying Frontend to Vercel Staging..."
          cd frontend
          
          # Link to Vercel project
          npx vercel link --yes --token=${{ secrets.VERCEL_TOKEN }}
          
          # Inject Env Vars for Staging
          npx vercel env add VITE_API_BASE_URL "${{ secrets.STAGING_API_URL }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          if [ -n "${{ secrets.GOOGLE_MAPS_API_KEY }}" ]; then
            npx vercel env add VITE_GOOGLE_MAPS_API_KEY "${{ secrets.GOOGLE_MAPS_API_KEY }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          fi
          
          # Deploy to Vercel (server-side build)
          npx vercel deploy --token=${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Deploy Backend to Vercel (Staging)
        shell: bash
        run: |
          echo "ðŸš€ Deploying Backend to Vercel Staging..."
          
          if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
            echo "::warning::VERCEL_BACKEND_PROJECT_ID secret is missing! Skipping backend deployment."
            exit 0
          fi

          cd backend
          
          # Link to Vercel project
          npx vercel link --yes --token=${{ secrets.VERCEL_TOKEN }}
          
          # Inject Env Vars for Staging
          npx vercel env add SUPABASE_URL "${{ secrets.SUPABASE_URL }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          npx vercel env add SUPABASE_KEY "${{ secrets.SUPABASE_KEY }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          if [ -n "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
            npx vercel env add SUPABASE_SERVICE_ROLE_KEY "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          fi

          # Deploy to Staging (server-side build)
          npx vercel deploy --token=${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}

      - name: Health Check
        if: ${{ inputs.skip_health_check != true }}
        run: |
          echo "ðŸ¥ Running health check..."
          
          # Wait for deployment to propagate
          echo "Waiting 45 seconds for deployment to propagate..."
          sleep 45
          
          # Health check with retries
          MAX_RETRIES=5
          RETRY_DELAY=10
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            # Check backend health
            if curl -sf --max-time 10 "${{ secrets.STAGING_API_URL }}/health" > /dev/null 2>&1; then
              echo "âœ… Backend health check passed!"
              BACKEND_OK=true
              break
            else
              echo "Backend not ready yet, retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done
          
          if [ "$BACKEND_OK" != "true" ]; then
             # Don't fail the pipeline if backend secret was missing (optional deployment)
             if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
                echo "âš ï¸ Backend check failed but VERCEL_BACKEND_PROJECT_ID was missing, so this is expected."
             else
                echo "âŒ Backend health check failed after $MAX_RETRIES attempts"
                exit 1
             fi
          fi
          
          echo "âœ… All health checks passed!"

      - name: Notify Deployment Success
        if: success()
        run: |
          echo "âœ… Staging deployment successful!"
          echo "ðŸ”— Frontend URL: https://staging.purrfect-spots.com"
          echo "ðŸ”— Backend URL: ${{ secrets.STAGING_API_URL }}"
          echo "ðŸ“¦ Version: ${{ needs.prepare.outputs.version }}"

      - name: Notify Deployment Failure
        if: failure()
        run: |
          echo "âŒ Staging deployment failed!"
          echo "Please check the logs for details."

  # ============================================================================
  # DEPLOY TO PRODUCTION
  # ============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: prepare
    outputs:
      frontend_url: ${{ steps.deploy-frontend.outputs.deployment_url }}
    if: needs.prepare.outputs.environment == 'production'
    environment:
      name: production
      url: https://purrfect-spots.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Pre-deployment backup
        run: |
          echo "ðŸ’¾ Creating pre-deployment backup..."
          
          # Trigger database backup via Supabase API or custom backup service
          if [ -n "${{ secrets.BACKUP_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.BACKUP_WEBHOOK_URL }}" \
              -H "Authorization: Bearer ${{ secrets.BACKUP_API_KEY }}" \
              -H "Content-Type: application/json" \
              -d '{"type": "pre-deployment", "version": "${{ needs.prepare.outputs.version }}"}'
            echo "Backup triggered successfully"
          else
            echo "::warning::No backup webhook configured. Skipping backup."
          fi

      - name: Deploy Frontend to Vercel (Production)
        id: deploy-frontend
        shell: bash
        run: |
          echo "ðŸš€ Deploying Frontend to Vercel Production..."
          cd frontend
          
          # Link to Vercel project (creates .vercel folder)
          npx vercel link --yes --token=${{ secrets.VERCEL_TOKEN }}
          
          # Inject Env Vars for Production
          npx vercel env add VITE_API_BASE_URL "${{ secrets.PROD_API_URL }}" production --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          if [ -n "${{ secrets.GOOGLE_MAPS_API_KEY }}" ]; then
            npx vercel env add VITE_GOOGLE_MAPS_API_KEY "${{ secrets.GOOGLE_MAPS_API_KEY }}" production --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          fi
          
          # Deploy to Vercel (server-side build) - no local build
          deployment_url=$(npx vercel deploy --prod --token=${{ secrets.VERCEL_TOKEN }} --yes --no-wait 2>&1 | grep -E '^https://' | head -1)
          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
          echo "âœ… Deployed to: $deployment_url"
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Deploy Backend to Vercel (Production)
        shell: bash
        run: |
          echo "ðŸš€ Deploying Backend to Vercel Production..."
          
          if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
            echo "::warning::VERCEL_BACKEND_PROJECT_ID secret is missing! Skipping backend deployment."
            exit 0
          fi
          
          cd backend
          
          # Link to Vercel project
          npx vercel link --yes --token=${{ secrets.VERCEL_TOKEN }}
          
          # Deploy to Production (server-side build)
          npx vercel deploy --prod --token=${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}

      - name: Health Check
        if: ${{ inputs.skip_health_check != true }}
        run: |
          echo "ðŸ¥ Running production health check..."
          
          # Wait for deployment to propagate
          echo "Waiting 60 seconds for production deployment to propagate..."
          sleep 60
          
          # Health check with retries (more attempts for production)
          MAX_RETRIES=10
          RETRY_DELAY=15
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            # Check backend health
            if curl -sf --max-time 15 "${{ secrets.PROD_API_URL }}/health" > /dev/null 2>&1; then
              echo "âœ… Backend health check passed!"
              
              # Check frontend
              # Use captured URL from deployment step
              FRONTEND_URL="${{ steps.deploy-frontend.outputs.deployment_url }}"
              if curl -sf --max-time 15 "$FRONTEND_URL" > /dev/null 2>&1; then
                echo "âœ… Frontend health check passed!"
                ALL_OK=true
                break
              fi
            fi
            
            echo "Services not ready yet, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done
          
          if [ "$ALL_OK" != "true" ]; then
            if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
               echo "âš ï¸ VERCEL_BACKEND_PROJECT_ID missing, so backend might not have deployed. Skipping failure."
            else
               echo "âŒ Production health check failed after $MAX_RETRIES attempts"
               echo "::error::Consider rolling back to previous version"
               exit 1
            fi
          fi
          
          echo "âœ… All production health checks passed!"

      - name: Smoke Tests
        run: |
          echo "ðŸ§ª Running smoke tests..."
          
          # Critical API endpoints smoke test
          echo "Testing critical endpoints..."
          
          # Test health endpoint
          curl -sf "${{ secrets.PROD_API_URL }}/health" | jq . || echo "Health endpoint check"
          
          # Test public endpoints (no auth required)
          curl -sf "${{ secrets.PROD_API_URL }}/api/v1/spots?limit=1" > /dev/null && echo "âœ… Spots API OK" || echo "::warning::Spots API check failed"
          
          echo "âœ… Smoke tests completed!"

      - name: Create Release Tag
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ·ï¸ Creating release tag..."
          
          VERSION="${{ needs.prepare.outputs.version }}"
          TAG_NAME="release-${VERSION}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create and push tag
          git tag -a "${TAG_NAME}" -m "Production release ${VERSION}"
          git push origin "${TAG_NAME}"
          
          # Create GitHub Release
          gh release create "${TAG_NAME}" \
            --title "Release ${VERSION}" \
            --notes "Automated production release\n\n- Version: ${VERSION}\n- Deployed by: ${{ github.actor }}\n- Commit: ${{ github.sha }}" \
            --latest
          
          echo "âœ… Release tag ${TAG_NAME} created and pushed"

      - name: Notify Deployment Success
        if: success()
        run: |
          echo "âœ… Production deployment successful!"
          echo "ðŸ”— URL: ${{ steps.deploy-frontend.outputs.deployment_url }}"
          echo "ðŸ“¦ Version: ${{ needs.prepare.outputs.version }}"

      - name: Notify Deployment Failure
        if: failure()
        run: |
          echo "âŒ Production deployment failed!"
          echo "ðŸ”„ Consider rolling back to previous version."

  # ============================================================================
  # DEPLOYMENT SUMMARY
  # ============================================================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [prepare, deploy-staging, deploy-production]
    if: always() && needs.prepare.outputs.should_deploy == 'true'
    steps:
      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.prepare.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${{ needs.prepare.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | ${{ needs.deploy-production.outputs.frontend_url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.prepare.outputs.environment }}" == "staging" ]; then
            echo "### Staging Deployment" >> $GITHUB_STEP_SUMMARY
            echo "| Status | ${{ needs.deploy-staging.result == 'success' && 'âœ… Success' || needs.deploy-staging.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
            echo "| URL | https://staging.purrfect-spots.com |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            echo "### Production Deployment" >> $GITHUB_STEP_SUMMARY
            echo "| Status | ${{ needs.deploy-production.result == 'success' && 'âœ… Success' || needs.deploy-production.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
            echo "| URL | ${{ needs.deploy-production.outputs.frontend_url }} |" >> $GITHUB_STEP_SUMMARY
          fi
