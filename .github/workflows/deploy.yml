# ==============================================================================
# Purrfect Spots - Deployment Pipeline
# ==============================================================================
# Handles deployment to staging and production environments on Vercel
#
# Deployment Strategy:
# - Staging: Auto-deploy on push to 'dev' branch (after CI passes)
# - Production: Manual trigger or auto-deploy on push to 'main' branch
#
# Prerequisites:
# - Configure repository secrets for each environment
# - Set up environment protection rules in GitHub Settings
# ==============================================================================

name: Deploy

on:
  # Trigger after CI/CD Pipeline completes successfully
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main, dev]

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      skip_health_check:
        description: "Skip health check after deployment"
        required: false
        type: boolean
        default: false

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false # Don't cancel in-progress deployments

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# ==============================================================================
# PERMISSIONS
# ==============================================================================
permissions:
  contents: read
  packages: write
  deployments: write
  id-token: write # For OIDC authentication

jobs:
  # ============================================================================
  # DETERMINE DEPLOYMENT TARGET
  # ============================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    # Only run if CI passed (for workflow_run) or always (for workflow_dispatch)
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4
        with:
          fetch-depth: 0

      - name: Determine environment
        id: set-env
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF: ${{ github.ref }}
          INPUT_ENV: ${{ inputs.environment }}
        run: |
          if [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            echo "environment=${INPUT_ENV}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$REF" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$REF" == "refs/heads/dev" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate version
        id: version
        run: |
          # Generate version based on git info
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)

          if [ "${{ steps.set-env.outputs.environment }}" == "production" ]; then
            # For production, try to use tag or generate semver-like version
            TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            VERSION="${TAG}-${SHORT_SHA}"
          else
            # For staging, use timestamp-based version
            VERSION="staging-${TIMESTAMP}-${SHORT_SHA}"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: ${VERSION}"

  # ============================================================================
  # DEPLOY TO STAGING
  # ============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.environment == 'staging'
    environment:
      name: staging
      url: ${{ vars.STAGING_FRONTEND_URL }}
    steps:
      - name: Checkout code
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4

      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4
        with:
          node-version: "20"

      - name: Deploy Frontend to Vercel (Staging)
        shell: bash
        run: |
          echo "ðŸš€ Deploying Frontend to Vercel Staging..."
          cd frontend

          # Link to Vercel project
          npx vercel link --yes --token=${{ secrets.VERCEL_TOKEN }} --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed"; exit 1; }

          # Inject Env Vars for Staging
          npx vercel env add VITE_API_BASE_URL "${{ secrets.STAGING_API_URL }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          if [ -n "${{ secrets.GOOGLE_MAPS_API_KEY }}" ]; then
            npx vercel env add VITE_GOOGLE_MAPS_API_KEY "${{ secrets.GOOGLE_MAPS_API_KEY }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          fi

          # Deploy to Vercel (server-side build)
          npx vercel deploy --token=${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Deploy Backend to Vercel (Staging)
        shell: bash
        run: |
          echo "ðŸš€ Deploying Backend to Vercel Staging..."

          if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
            echo "::warning::VERCEL_BACKEND_PROJECT_ID secret is missing! Skipping backend deployment."
            exit 0
          fi

          cd backend

          # Link to Vercel project
          npx vercel link --yes --token=${{ secrets.VERCEL_TOKEN }} --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed for backend"; exit 1; }

          # Inject Env Vars for Staging
          npx vercel env add SUPABASE_URL "${{ secrets.SUPABASE_URL }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          npx vercel env add SUPABASE_KEY "${{ secrets.SUPABASE_KEY }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          if [ -n "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
            npx vercel env add SUPABASE_SERVICE_ROLE_KEY "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" preview --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          fi

          # Deploy to Staging (server-side build)
          npx vercel deploy --token=${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}

      - name: Health Check
        if: ${{ inputs.skip_health_check != true }}
        run: |
          echo "ðŸ¥ Running health check..."

          # Wait for deployment to propagate
          echo "Waiting 10 seconds for service startup..."
          sleep 10

          # Health check with retries
          MAX_RETRIES=20
          RETRY_DELAY=10

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            # Check backend health
            if curl -sf --max-time 10 "${{ secrets.STAGING_API_URL }}/health" > /dev/null 2>&1; then
              echo "âœ… Backend health check passed!"
              BACKEND_OK=true
              break
            else
              echo "Backend not ready yet, retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done

          if [ "$BACKEND_OK" != "true" ]; then
             # Don't fail the pipeline if backend secret was missing (optional deployment)
             if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
                echo "âš ï¸ Backend check failed but VERCEL_BACKEND_PROJECT_ID was missing, so this is expected."
             else
                echo "âŒ Backend health check failed after $MAX_RETRIES attempts"
                exit 1
             fi
          fi

          echo "âœ… All health checks passed!"

      - name: Notify Deployment Success
        if: success()
        run: |
          echo "âœ… Staging deployment successful!"
          echo "ðŸ”— Frontend URL: ${{ secrets.STAGING_FRONTEND_URL }}"
          echo "ðŸ”— Backend URL: ${{ secrets.STAGING_API_URL }}"
          echo "ðŸ“¦ Version: ${{ needs.prepare.outputs.version }}"

      - name: Notify Deployment Failure
        if: failure()
        run: |
          echo "âŒ Staging deployment failed!"
          echo "Please check the logs for details."

  # ============================================================================
  # DEPLOY TO PRODUCTION
  # ============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: prepare
    outputs:
      frontend_url: ${{ steps.deploy-frontend.outputs.deployment_url }}
    if: needs.prepare.outputs.environment == 'production'
    environment:
      name: production
      url: https://purrfect-spots.vercel.app
    steps:
      - name: Checkout code
        uses: actions/checkout@0ad4b8fadaa221de15dcec353f45205ec38ea70b # v4

      - name: Setup Node.js
        uses: actions/setup-node@1e60f620b9541d16bece96c5465dc8ee9832be0b # v4
        with:
          node-version: "20"

      - name: Pre-deployment backup
        run: |
          echo "ðŸ’¾ Creating pre-deployment backup..."

          # Trigger database backup via Supabase API or custom backup service
          if [ -n "${{ secrets.BACKUP_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.BACKUP_WEBHOOK_URL }}" \
              -H "Authorization: Bearer ${{ secrets.BACKUP_API_KEY }}" \
              -H "Content-Type: application/json" \
              -d '{"type": "pre-deployment", "version": "${{ needs.prepare.outputs.version }}"}'
            echo "Backup triggered successfully"
          else
            echo "::warning::No backup webhook configured. Skipping backup."
          fi

      - name: Deploy Frontend to Vercel (Production)
        id: deploy-frontend
        shell: bash
        run: |
          echo "ðŸš€ Deploying Frontend to Vercel Production..."

          # Check Secrets presence
          if [ -z "${{ secrets.VERCEL_TOKEN }}" ]; then
            echo "::error::VERCEL_TOKEN is not set"
            exit 1
          fi
          if [ -z "$VERCEL_ORG_ID" ]; then
            echo "::error::VERCEL_ORG_ID is not set"
            exit 1
          fi
          if [ -z "$VERCEL_PROJECT_ID" ]; then
             echo "::error::VERCEL_PROJECT_ID is not set"
             exit 1
          fi

          cd frontend

          # Link to Vercel project (creates .vercel folder)
          echo "ðŸ”— Linking to Vercel project..."
          npx vercel link --yes --token=${{ secrets.VERCEL_TOKEN }} --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed"; exit 1; }

          # Inject Env Vars for Production
          echo "ðŸ”§ Injecting environment variables..."
          npx vercel env add VITE_API_BASE_URL "${{ secrets.PROD_API_URL }}" production --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          if [ -n "${{ secrets.GOOGLE_MAPS_API_KEY }}" ]; then
            npx vercel env add VITE_GOOGLE_MAPS_API_KEY "${{ secrets.GOOGLE_MAPS_API_KEY }}" production --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          fi

          # Deploy to Vercel (server-side build)
          echo "ðŸš€ Triggering Vercel User Deployment..."

          DEPLOY_OUTPUT=$(npx vercel deploy --prod --token=${{ secrets.VERCEL_TOKEN }} --yes)
          DEPLOY_EXIT_CODE=$?

          if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
            echo "::error::Vercel deployment failed"
            echo "$DEPLOY_OUTPUT"
            exit $DEPLOY_EXIT_CODE
          fi

          deployment_url=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[a-zA-Z0-9.-]+\.vercel\.app' | head -1)

          if [ -z "$deployment_url" ]; then
            echo "::error::Deployment succeeded but no URL found"
            echo "$DEPLOY_OUTPUT"
            exit 1
          fi

          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
          echo "âœ… Deployed to: $deployment_url"
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Deploy Backend to Vercel (Production)
        shell: bash
        run: |
          echo "ðŸš€ Deploying Backend to Vercel Production..."

          if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
            echo "::warning::VERCEL_BACKEND_PROJECT_ID secret is missing! Skipping backend deployment."
            exit 0
          fi

          if [ -z "$VERCEL_ORG_ID" ]; then
             echo "::error::VERCEL_ORG_ID is not set (Backend)"
             exit 1
          fi

          cd backend

          # Link to Vercel project
          echo "ðŸ”— Linking Backend to Vercel..."
          npx vercel link --yes --token=${{ secrets.VERCEL_TOKEN }} --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed for backend"; exit 1; }

          # Inject Env Vars for Production
          echo "ðŸ”§ Injecting environment variables..."
          npx vercel env add SUPABASE_URL "${{ secrets.SUPABASE_URL }}" production --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          npx vercel env add SUPABASE_KEY "${{ secrets.SUPABASE_KEY }}" production --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          if [ -n "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" ]; then
            npx vercel env add SUPABASE_SERVICE_ROLE_KEY "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" production --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          fi
          # Also inject JWT_SECRET if available (Required by config.py)
          if [ -n "${{ secrets.JWT_SECRET }}" ]; then
            npx vercel env add JWT_SECRET "${{ secrets.JWT_SECRET }}" production --force --token=${{ secrets.VERCEL_TOKEN }} --yes 2>/dev/null || true
          fi

          # Deploy to Production (server-side build)
          echo "ðŸš€ Triggering Backend Deployment..."
          npx vercel deploy --prod --token=${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}

      - name: Health Check
        if: ${{ inputs.skip_health_check != true }}
        run: |
          echo "ðŸ¥ Running production health check..."

          # Wait for deployment to propagate
          echo "Waiting 15 seconds for service startup..."
          sleep 15

          # Health check with retries (more attempts for production)
          MAX_RETRIES=30
          RETRY_DELAY=10

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            # Check backend health
            if curl -sf --max-time 15 "${{ secrets.PROD_API_URL }}/health" > /dev/null 2>&1; then
              echo "âœ… Backend health check passed!"
              
              # Check frontend
              # Use captured URL from deployment step
              FRONTEND_URL="${{ steps.deploy-frontend.outputs.deployment_url }}"
              if curl -sf --max-time 15 "$FRONTEND_URL" > /dev/null 2>&1; then
                echo "âœ… Frontend health check passed!"
                ALL_OK=true
                break
              fi
            fi
            
            echo "Services not ready yet, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done

          if [ "$ALL_OK" != "true" ]; then
            if [ -z "${{ secrets.VERCEL_BACKEND_PROJECT_ID }}" ]; then
               echo "âš ï¸ VERCEL_BACKEND_PROJECT_ID missing, so backend might not have deployed. Skipping failure."
            else
               echo "âŒ Production health check failed after $MAX_RETRIES attempts"
               echo "::error::Consider rolling back to previous version"
               exit 1
            fi
          fi

          echo "âœ… All production health checks passed!"

      - name: Smoke Tests
        run: |
          echo "ðŸ§ª Running smoke tests..."

          # Critical API endpoints smoke test
          echo "Testing critical endpoints..."

          # Test health endpoint
          curl -sf "${{ secrets.PROD_API_URL }}/health" | jq . || echo "Health endpoint check"

          # Test public endpoints (no auth required)
          curl -sf "${{ secrets.PROD_API_URL }}/api/v1/spots?limit=1" > /dev/null && echo "âœ… Spots API OK" || echo "::warning::Spots API check failed"

          echo "âœ… Smoke tests completed!"

      - name: Create Release Tag
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ·ï¸ Creating release tag..."

          VERSION="${{ needs.prepare.outputs.version }}"
          TAG_NAME="release-${VERSION}"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create and push tag
          git tag -a "${TAG_NAME}" -m "Production release ${VERSION}"
          git push origin "${TAG_NAME}"

          # Create GitHub Release
          gh release create "${TAG_NAME}" \
            --title "Release ${VERSION}" \
            --notes "Automated production release\n\n- Version: ${VERSION}\n- Deployed by: ${{ github.actor }}\n- Commit: ${{ github.sha }}" \
            --latest

          echo "âœ… Release tag ${TAG_NAME} created and pushed"

      - name: Notify Deployment Success
        if: success()
        run: |
          echo "âœ… Production deployment successful!"
          echo "ðŸ”— URL: ${{ steps.deploy-frontend.outputs.deployment_url }}"
          echo "ðŸ“¦ Version: ${{ needs.prepare.outputs.version }}"

      - name: Notify Deployment Failure
        if: failure()
        run: |
          echo "âŒ Production deployment failed!"
          echo "ðŸ”„ Consider rolling back to previous version."

  # ============================================================================
  # DEPLOYMENT SUMMARY
  # ============================================================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [prepare, deploy-staging, deploy-production]
    if: always() && needs.prepare.outputs.should_deploy == 'true'
    steps:
      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ needs.prepare.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${{ needs.prepare.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | ${{ needs.deploy-production.outputs.frontend_url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.prepare.outputs.environment }}" == "staging" ]; then
            echo "### Staging Deployment" >> $GITHUB_STEP_SUMMARY
            echo "| Status | ${{ needs.deploy-staging.result == 'success' && 'âœ… Success' || needs.deploy-staging.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
            echo "| URL | ${{ secrets.STAGING_FRONTEND_URL }} |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            echo "### Production Deployment" >> $GITHUB_STEP_SUMMARY
            echo "| Status | ${{ needs.deploy-production.result == 'success' && 'âœ… Success' || needs.deploy-production.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
            echo "| URL | ${{ needs.deploy-production.outputs.frontend_url }} |" >> $GITHUB_STEP_SUMMARY
          fi
