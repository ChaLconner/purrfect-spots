# ==============================================================================
# Purrfect Spots - Deployment Pipeline (Production)
# ==============================================================================
# Handles deployment to staging and production environments on Vercel
#
# Deployment Strategy:
# - Staging: Auto-deploy on push to 'dev' branch (after CI passes)
# - Production: Manual trigger or auto-deploy on push to 'main' branch
#
# Security:
# - All secrets accessed via env vars only, never in shell interpolation
# - All actions pinned to full SHA
# - Minimal permissions scope per job
#
# Prerequisites:
# - Configure repository secrets for each environment
# - Set up environment protection rules in GitHub Settings
# ==============================================================================

name: Deploy

on:
  # Trigger after CI/CD Pipeline completes successfully
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main, dev]

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      skip_health_check:
        description: "Skip health check after deployment"
        required: false
        type: boolean
        default: false

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true # Cancel pending deploys; only the latest commit deploys

# ==============================================================================
# PERMISSIONS - Principle of least privilege
# ==============================================================================
permissions:
  contents: read
  packages: write
  deployments: write
  id-token: write

jobs:
  # ============================================================================
  # DETERMINE DEPLOYMENT TARGET
  # ============================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.status == 'completed')
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}
      start_time: ${{ steps.timer.outputs.start_time }}
    steps:
      - name: Start Timer
        id: timer
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4.2.2
        with:
          fetch-depth: 0

      - name: Validate required secrets
        id: validate-secrets
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF: ${{ github.ref }}
          INPUT_ENV: ${{ inputs.environment }}
          HAS_VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN != '' }}
          HAS_STAGING_API_URL: ${{ secrets.STAGING_API_URL != '' }}
          HAS_PROD_API_URL: ${{ secrets.PROD_API_URL != '' }}
          HAS_SUPABASE_URL: ${{ secrets.SUPABASE_URL != '' }}
          HAS_SUPABASE_KEY: ${{ secrets.SUPABASE_KEY != '' }}
        run: |
          echo "ðŸ”’ Validating required secrets..."

          # Determine target environment
          if [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            TARGET_ENV="$INPUT_ENV"
          elif [ "$REF" == "refs/heads/main" ]; then
            TARGET_ENV="production"
          elif [ "$REF" == "refs/heads/dev" ]; then
            TARGET_ENV="staging"
          else
            TARGET_ENV="none"
          fi

          # Validate secrets for staging
          if [ "$TARGET_ENV" == "staging" ]; then
            if [ "$HAS_VERCEL_TOKEN" != "true" ]; then
              echo "::error::VERCEL_TOKEN is required for staging deployment"
              exit 1
            fi
            if [ "$HAS_STAGING_API_URL" != "true" ]; then
              echo "::warning::STAGING_API_URL is not set. Deployment may fail."
            fi
          fi

          # Validate secrets for production
          if [ "$TARGET_ENV" == "production" ]; then
            if [ "$HAS_VERCEL_TOKEN" != "true" ]; then
              echo "::error::VERCEL_TOKEN is required for production deployment"
              exit 1
            fi
            if [ "$HAS_PROD_API_URL" != "true" ]; then
              echo "::error::PROD_API_URL is required for production deployment"
              exit 1
            fi
            if [ "$HAS_SUPABASE_URL" != "true" ]; then
              echo "::error::SUPABASE_URL is required for production deployment"
              exit 1
            fi
            if [ "$HAS_SUPABASE_KEY" != "true" ]; then
              echo "::error::SUPABASE_KEY is required for production deployment"
              exit 1
            fi
          fi

          echo "âœ… Secrets validation passed"

      - name: Determine environment
        id: set-env
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF: ${{ github.ref }}
          INPUT_ENV: ${{ inputs.environment }}
        run: |
          if [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            echo "environment=${INPUT_ENV}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$REF" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$REF" == "refs/heads/dev" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate version
        id: version
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)

          if [ "${{ steps.set-env.outputs.environment }}" == "production" ]; then
            TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            VERSION="${TAG}-${SHORT_SHA}"
          else
            VERSION="staging-${TIMESTAMP}-${SHORT_SHA}"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: ${VERSION}"

  # ============================================================================
  # STAGING - PARALLEL DEPLOYMENTS
  # ============================================================================
  staging-frontend:
    name: Staging - Frontend
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.environment == 'staging'
    environment: { name: staging, url: ${{ vars.STAGING_FRONTEND_URL }} }
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: 'npm'

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Authenticate Vercel
        run: vercel whoami --token="${{ secrets.VERCEL_TOKEN }}"

      - name: Cache API Client Node Modules
        uses: actions/cache@v4
        with:
          path: api-client/node_modules
          key: ${{ runner.os }}-api-client-${{ hashFiles('api-client/package.json') }}

      - name: Validate API Client Generation
        run: |
          echo "ðŸ§ª Validating API Client Generation..."
          cd api-client
          [ -d node_modules ] || npm install --prefer-offline --no-audit
          npm run validate

      - name: Deploy Frontend to Vercel (Staging)
        shell: bash
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          STAGING_API_URL: ${{ secrets.STAGING_API_URL }}
          GOOGLE_MAPS_API_KEY: ${{ secrets.GOOGLE_MAPS_API_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
        run: |
          echo "ðŸš€ Linking and Pulling Frontend Config..."
          # Use vercel link/pull to establish project context
          vercel link --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" --scope "$VERCEL_ORG_ID"
          vercel pull --yes --environment=preview --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID"

          echo "ðŸ”§ Injecting environment variables..."
          echo "$STAGING_API_URL" | vercel env add VITE_API_BASE_URL preview --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" 2>/dev/null || true
          
          # Prepare Build env flags
          BUILD_ENV_FLAGS="--build-env VITE_SUPABASE_URL=$SUPABASE_URL"
          BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_SUPABASE_ANON_KEY=$SUPABASE_KEY"
          [ -n "$STAGING_API_URL" ] && BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_API_BASE_URL=$STAGING_API_URL"
          [ -n "$GOOGLE_MAPS_API_KEY" ] && BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_GOOGLE_MAPS_API_KEY=$GOOGLE_MAPS_API_KEY"

          echo "ðŸš€ Deploying Frontend..."
          vercel deploy \
            --yes \
            --token="$VERCEL_TOKEN" \
            --scope="$VERCEL_ORG_ID" \
            $BUILD_ENV_FLAGS

  staging-backend:
    name: Staging - Backend
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.environment == 'staging'
    environment: { name: staging }
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: 'npm'

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Authenticate Vercel
        run: vercel whoami --token="${{ secrets.VERCEL_TOKEN }}"

      - name: Deploy Backend to Vercel (Staging)
        shell: bash
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
        run: |
          echo "ðŸš€ Linking and Pulling Backend Config..."
          # Prevent project configuration conflicts
          rm -rf .vercel
          vercel link --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" --scope "$VERCEL_ORG_ID"
          vercel pull --yes --environment=preview --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID"

          echo "ðŸ”§ Injecting environment variables..."
          echo "$SUPABASE_URL" | vercel env add SUPABASE_URL preview --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" 2>/dev/null || true
          echo "$SUPABASE_KEY" | vercel env add SUPABASE_KEY preview --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" 2>/dev/null || true

          echo "ðŸš€ Deploying Backend..."
          vercel deploy \
            --yes \
            --token="$VERCEL_TOKEN" \
            --scope="$VERCEL_ORG_ID"

  staging-verify:
    name: Staging - Verification
    runs-on: ubuntu-latest
    needs: [prepare, staging-frontend, staging-backend]
    if: always() && needs.prepare.outputs.environment == 'staging'
    steps:
      - name: Staging Health Check
        if: inputs.skip_health_check != true && needs.staging-frontend.result == 'success' && needs.staging-backend.result == 'success'
        env:
          STAGING_API_URL: ${{ secrets.STAGING_API_URL }}
        run: |
          echo "ðŸ¥ Running staging health check..."
          sleep 10
          curl -sf --max-time 15 "${STAGING_API_URL}/health/ready" || (echo "âŒ Staging Health Check Failed" && exit 1)
          echo "âœ… Staging Backend is Healthy"

      - name: Notify Staging Result
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          FE_RESULT: ${{ needs.staging-frontend.result }}
          BE_RESULT: ${{ needs.staging-backend.result }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          if [ "$FE_RESULT" == "success" ] && [ "$BE_RESULT" == "success" ]; then
            TITLE="âœ… Staging Deployment Successful"
            COLOR_SLACK="good"
            COLOR_DISCORD=5763719
          else
            TITLE="âŒ Staging Deployment Failed"
            COLOR_SLACK="danger"
            COLOR_DISCORD=15548997
          fi
          
          [ -n "$SLACK_WEBHOOK_URL" ] && curl -X POST "$SLACK_WEBHOOK_URL" -H "Content-Type: application/json" -d "{\"text\": \"${TITLE}\", \"attachments\": [{\"color\": \"${COLOR_SLACK}\", \"fields\": [{\"title\": \"Environment\", \"value\": \"Staging\", \"short\": true}, {\"title\": \"Version\", \"value\": \"${VERSION}\", \"short\": true}]}]}" 2>/dev/null || true
          [ -n "$DISCORD_WEBHOOK_URL" ] && curl -X POST "$DISCORD_WEBHOOK_URL" -H "Content-Type: application/json" -d "{\"embeds\": [{\"title\": \"${TITLE}\", \"color\": ${COLOR_DISCORD}, \"fields\": [{\"name\": \"Environment\", \"value\": \"Staging\"}, {\"name\": \"Version\", \"value\": \"${VERSION}\"}]}]}" 2>/dev/null || true
          echo "Notifying: $TITLE"

  # ============================================================================
  # PRODUCTION - MODULAR FLOW
  # ============================================================================
  production-backup:
    name: Production - Backup
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.environment == 'production'
    steps:
      - name: Pre-deployment backup
        env:
          BACKUP_WEBHOOK_URL: ${{ secrets.BACKUP_WEBHOOK_URL }}
          BACKUP_API_KEY: ${{ secrets.BACKUP_API_KEY }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "ðŸ’¾ Creating pre-deployment backup..."
          if [ -n "$BACKUP_WEBHOOK_URL" ]; then
            curl -X POST "$BACKUP_WEBHOOK_URL" \
              -H "Authorization: Bearer $BACKUP_API_KEY" \
              -H "Content-Type: application/json" \
              -d "{\"type\": \"pre-deployment\", \"version\": \"${VERSION}\"}"
          fi

  production-frontend:
    name: Production - Frontend
    runs-on: ubuntu-latest
    needs: [prepare, production-backup]
    if: needs.prepare.outputs.environment == 'production'
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
    environment: { name: production, url: https://purrfect-spots.vercel.app }
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with: { node-version: "20", cache: 'npm' }
      - name: Install Vercel CLI
        run: npm install -g vercel@latest
      - name: Authenticate Vercel
        run: vercel whoami --token="${{ secrets.VERCEL_TOKEN }}"
      - id: deploy
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          PROD_API_URL: ${{ secrets.PROD_API_URL }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          GOOGLE_MAPS_API_KEY: ${{ secrets.GOOGLE_MAPS_API_KEY }}
        run: |
          echo "ðŸš€ Linking and Pulling Frontend Production Config..."
          vercel link --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" --scope "$VERCEL_ORG_ID"
          vercel pull --yes --environment=production --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID"

          echo "ðŸ”§ Injecting environment variables..."
          echo "$PROD_API_URL" | vercel env add VITE_API_BASE_URL production --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" 2>/dev/null || true

          VITE_FLAGS="--build-env VITE_SUPABASE_URL=$SUPABASE_URL --build-env VITE_SUPABASE_ANON_KEY=$SUPABASE_KEY"
          [ -n "$PROD_API_URL" ] && VITE_FLAGS="$VITE_FLAGS --build-env VITE_API_BASE_URL=$PROD_API_URL"
          [ -n "$GOOGLE_MAPS_API_KEY" ] && VITE_FLAGS="$VITE_FLAGS --build-env VITE_GOOGLE_MAPS_API_KEY=$GOOGLE_MAPS_API_KEY"
          
          echo "ðŸš€ Triggering Vercel Production Deployment..."
          DEPLOY_OUTPUT=$(vercel deploy --prod --yes --token="$VERCEL_TOKEN" --scope="$VERCEL_ORG_ID" $VITE_FLAGS)
          URL=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[a-zA-Z0-9.-]+\.vercel\.app' | head -1)
          echo "deployment_url=$URL" >> $GITHUB_OUTPUT
          echo "âœ… Deployed to: $URL"

  production-backend:
    name: Production - Backend
    runs-on: ubuntu-latest
    needs: [prepare, production-backup]
    if: needs.prepare.outputs.environment == 'production'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with: { node-version: "20", cache: 'npm' }
      - name: Install Vercel CLI
        run: npm install -g vercel@latest
      - name: Authenticate Vercel
        run: vercel whoami --token="${{ secrets.VERCEL_TOKEN }}"
      - name: Deploy Backend
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
        run: |
          echo "ðŸš€ Linking and Pulling Backend Production Config..."
          rm -rf .vercel
          vercel link --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" --scope "$VERCEL_ORG_ID"
          vercel pull --yes --environment=production --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID"

          echo "ðŸ”§ Injecting environment variables..."
          echo "$SUPABASE_URL" | vercel env add SUPABASE_URL production --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" 2>/dev/null || true
          echo "$SUPABASE_KEY" | vercel env add SUPABASE_KEY production --force --yes --token="$VERCEL_TOKEN" --scope "$VERCEL_ORG_ID" 2>/dev/null || true

          echo "ðŸš€ Triggering Backend Deployment..."
          vercel deploy --prod --yes --token="$VERCEL_TOKEN" --scope="$VERCEL_ORG_ID"

  production-verify:
    name: Production - Verification
    runs-on: ubuntu-latest
    needs: [prepare, production-frontend, production-backend]
    if: always() && needs.prepare.outputs.environment == 'production'
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Smoke Tests
        if: needs.production-frontend.result == 'success' && needs.production-backend.result == 'success'
        env:
          PROD_API_URL: ${{ secrets.PROD_API_URL }}
        run: |
          echo "ðŸ§ª Running Smoke Tests..."
          sleep 15
          curl -sf "${PROD_API_URL}/health/ready" || exit 1
          echo "âœ… Backend integration check passed"

      - name: Create Release Tag
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "ðŸ·ï¸ Creating release tag..."

          TAG_NAME="release-${VERSION}"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create and push tag
          git tag -a "${TAG_NAME}" -m "Production release ${VERSION}"
          git push origin "${TAG_NAME}"

          # Create GitHub Release
          gh release create "${TAG_NAME}" \
            --title "Release ${VERSION}" \
            --notes "Automated production release

          - Version: ${VERSION}
          - Deployed by: ${{ github.actor }}
          - Commit: ${{ github.sha }}" \
            --latest

          echo "âœ… Release tag ${TAG_NAME} created and pushed"

      - name: Rollback on Failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_BACKEND_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "ðŸ”„ Initiating rollback..."

          PREVIOUS_TAG=$(git describe --tags --abbrev=0 --exclude="release-${VERSION}" 2>/dev/null || echo "")

          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Rolling back to $PREVIOUS_TAG"

            # Rollback frontend (use --project flag, don't cd)
            echo "Rolling back frontend..."
            vercel rollback --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" || echo "::warning::Frontend rollback failed"

            # Rollback backend if configured
            if [ -n "$VERCEL_BACKEND_PROJECT_ID" ]; then
              echo "Rolling back backend..."
              vercel rollback --yes --token="$VERCEL_TOKEN" --project "$VERCEL_BACKEND_PROJECT_ID" || echo "::warning::Backend rollback failed"
            fi

            echo "âœ… Rollback completed"
          else
            echo "::warning::No previous tag found for rollback â€“ this appears to be the first deployment."
            echo "â„¹ï¸ Manual intervention may be needed. Check the deployment dashboard."
          fi

      - name: Notify Deployment Result
        if: always()
        env:
          FRONTEND_URL: ${{ steps.deploy-frontend.outputs.deployment_url }}
          VERSION: ${{ needs.prepare.outputs.version }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          JOB_STATUS: ${{ job.status }}
        run: |
          if [ "$JOB_STATUS" == "success" ]; then
            echo "âœ… Production deployment successful!"
            echo "ðŸ”— URL: ${FRONTEND_URL}"
            echo "ðŸ“¦ Version: ${VERSION}"
            COLOR_SLACK="good"
            COLOR_DISCORD=5763719
            TITLE="âœ… Production Deployment Successful"
          else
            echo "âŒ Production deployment failed!"
            echo "ðŸ”„ Rollback initiated automatically."
            COLOR_SLACK="danger"
            COLOR_DISCORD=15548997
            TITLE="âŒ Production Deployment Failed - Rollback Initiated"
          fi

          # Send Slack notification
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -X POST "$SLACK_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -d "{
                \"text\": \"${TITLE}\",
                \"attachments\": [{
                  \"color\": \"${COLOR_SLACK}\",
                  \"fields\": [
                    {\"title\": \"Environment\", \"value\": \"Production\", \"short\": true},
                    {\"title\": \"Version\", \"value\": \"${VERSION}\", \"short\": true},
                    {\"title\": \"URL\", \"value\": \"${FRONTEND_URL}\", \"short\": false},
                    {\"title\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                    {\"title\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"short\": false}
                  ]
                }]
              }" 2>/dev/null || echo "Slack notification failed"
          fi

          # Send Discord notification
          if [ -n "$DISCORD_WEBHOOK_URL" ]; then
            curl -X POST "$DISCORD_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -d "{
                \"embeds\": [{
                  \"title\": \"${TITLE}\",
                  \"color\": ${COLOR_DISCORD},
                  \"fields\": [
                    {\"name\": \"Environment\", \"value\": \"Production\", \"inline\": true},
                    {\"name\": \"Version\", \"value\": \"${VERSION}\", \"inline\": true},
                    {\"name\": \"URL\", \"value\": \"${FRONTEND_URL}\"},
                    {\"name\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                    {\"name\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}
                  ]
                }]
              }" 2>/dev/null || echo "Discord notification failed"
          fi

  # ============================================================================
  # DEPLOYMENT SUMMARY
  # ============================================================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [prepare, staging-verify, production-verify]
    if: always() && needs.prepare.outputs.should_deploy == 'true'
    steps:
      - name: Create deployment summary
        env:
          ENVIRONMENT: ${{ needs.prepare.outputs.environment }}
          VERSION: ${{ needs.prepare.outputs.version }}
          FRONTEND_URL: ${{ needs.production-frontend.outputs.deployment_url }}
          STAGING_RESULT: ${{ needs.staging-verify.result }}
          PRODUCTION_RESULT: ${{ needs.production-verify.result }}
          START_TIME: ${{ needs.prepare.outputs.start_time }}
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${ENVIRONMENT} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${VERSION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | ${FRONTEND_URL} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${ENVIRONMENT}" == "staging" ]; then
            echo "### Staging Deployment" >> $GITHUB_STEP_SUMMARY
            STATUS="âŒ Failed"
            [ "${STAGING_RESULT}" == "success" ] && STATUS="âœ… Success"
            [ "${STAGING_RESULT}" == "skipped" ] && STATUS="â­ï¸ Skipped"
            echo "| Status | ${STATUS} |" >> $GITHUB_STEP_SUMMARY
          elif [ "${ENVIRONMENT}" == "production" ]; then
            echo "### Production Deployment" >> $GITHUB_STEP_SUMMARY
            STATUS="âŒ Failed"
            [ "${PRODUCTION_RESULT}" == "success" ] && STATUS="âœ… Success"
            [ "${PRODUCTION_RESULT}" == "skipped" ] && STATUS="â­ï¸ Skipped"
            echo "| Status | ${STATUS} |" >> $GITHUB_STEP_SUMMARY
            echo "| URL | ${FRONTEND_URL} |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Deployment Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run ID**: \`${{ github.run_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ github.server_url }}/${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Calculate deployment duration
          if [ -n "$START_TIME" ] && [ "$START_TIME" != "null" ]; then
            END_TIME=$(date +%s)
            DURATION=$((END_TIME - START_TIME))
            if [ $DURATION -gt 0 ]; then
              MINUTES=$((DURATION / 60))
              SECONDS=$((DURATION % 60))
              echo "- **Deployment Duration**: ${MINUTES}m ${SECONDS}s" >> $GITHUB_STEP_SUMMARY
            fi
          fi
