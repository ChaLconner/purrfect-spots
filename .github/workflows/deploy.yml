# ==============================================================================
# Purrfect Spots - Deployment Pipeline (Production)
# ==============================================================================
# Handles deployment to staging and production environments on Vercel
#
# Deployment Strategy:
# - Staging: Auto-deploy on push to 'dev' branch (after CI passes)
# - Production: Manual trigger or auto-deploy on push to 'main' branch
#
# Security:
# - All secrets accessed via env vars only, never in shell interpolation
# - All actions pinned to full SHA
# - Minimal permissions scope per job
#
# Prerequisites:
# - Configure repository secrets for each environment
# - Set up environment protection rules in GitHub Settings
# ==============================================================================

name: Deploy

on:
  # Trigger after CI/CD Pipeline completes successfully
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [main, dev]

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      skip_health_check:
        description: "Skip health check after deployment"
        required: false
        type: boolean
        default: false

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true # Cancel pending deploys; only the latest commit deploys

# ==============================================================================
# PERMISSIONS - Principle of least privilege
# ==============================================================================
permissions:
  contents: read
  packages: write
  deployments: write
  id-token: write

jobs:
  # ============================================================================
  # DETERMINE DEPLOYMENT TARGET
  # ============================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.status == 'completed')
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}
      start_time: ${{ steps.timer.outputs.start_time }}
    steps:
      - name: Start Timer
        id: timer
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4.2.2
        with:
          fetch-depth: 0

      - name: Validate required secrets
        id: validate-secrets
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF: ${{ github.ref }}
          INPUT_ENV: ${{ inputs.environment }}
          HAS_VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN != '' }}
          HAS_STAGING_API_URL: ${{ secrets.STAGING_API_URL != '' }}
          HAS_PROD_API_URL: ${{ secrets.PROD_API_URL != '' }}
          HAS_SUPABASE_URL: ${{ secrets.SUPABASE_URL != '' }}
          HAS_SUPABASE_KEY: ${{ secrets.SUPABASE_KEY != '' }}
        run: |
          echo "ðŸ”’ Validating required secrets..."

          # Determine target environment
          if [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            TARGET_ENV="$INPUT_ENV"
          elif [ "$REF" == "refs/heads/main" ]; then
            TARGET_ENV="production"
          elif [ "$REF" == "refs/heads/dev" ]; then
            TARGET_ENV="staging"
          else
            TARGET_ENV="none"
          fi

          # Validate secrets for staging
          if [ "$TARGET_ENV" == "staging" ]; then
            if [ "$HAS_VERCEL_TOKEN" != "true" ]; then
              echo "::error::VERCEL_TOKEN is required for staging deployment"
              exit 1
            fi
            if [ "$HAS_STAGING_API_URL" != "true" ]; then
              echo "::warning::STAGING_API_URL is not set. Deployment may fail."
            fi
          fi

          # Validate secrets for production
          if [ "$TARGET_ENV" == "production" ]; then
            if [ "$HAS_VERCEL_TOKEN" != "true" ]; then
              echo "::error::VERCEL_TOKEN is required for production deployment"
              exit 1
            fi
            if [ "$HAS_PROD_API_URL" != "true" ]; then
              echo "::error::PROD_API_URL is required for production deployment"
              exit 1
            fi
            if [ "$HAS_SUPABASE_URL" != "true" ]; then
              echo "::error::SUPABASE_URL is required for production deployment"
              exit 1
            fi
            if [ "$HAS_SUPABASE_KEY" != "true" ]; then
              echo "::error::SUPABASE_KEY is required for production deployment"
              exit 1
            fi
          fi

          echo "âœ… Secrets validation passed"

      - name: Determine environment
        id: set-env
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF: ${{ github.ref }}
          INPUT_ENV: ${{ inputs.environment }}
        run: |
          if [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            echo "environment=${INPUT_ENV}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$REF" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "$REF" == "refs/heads/dev" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate version
        id: version
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)

          if [ "${{ steps.set-env.outputs.environment }}" == "production" ]; then
            TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            VERSION="${TAG}-${SHORT_SHA}"
          else
            VERSION="staging-${TIMESTAMP}-${SHORT_SHA}"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: ${VERSION}"

  # ============================================================================
  # DEPLOY TO STAGING
  # ============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: prepare
    if: needs.prepare.outputs.environment == 'staging'
    environment:
      name: staging
      url: ${{ vars.STAGING_FRONTEND_URL }}
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4

      - name: Setup Node.js
        uses: actions/setup-node@8f152de45cc393bb48ce5d89d36b731f54556e65 # v4.4.2
        with:
          node-version: "20"

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Validate API Client Generation
        run: |
          echo "ðŸ§ª Validating API Client Generation..."
          cd api-client
          npm install --prefer-offline --no-audit --no-workspaces
          npm run validate

      - name: Deploy Frontend to Vercel (Staging)
        shell: bash
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          STAGING_API_URL: ${{ secrets.STAGING_API_URL }}
          GOOGLE_MAPS_API_KEY: ${{ secrets.GOOGLE_MAPS_API_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
        run: |
          echo "ðŸš€ Deploying Frontend to Vercel Staging..."
          # NOTE: Do NOT cd into frontend/ here. The Vercel project settings
          # have Root Directory set to 'frontend', so deploying from repo root is correct.

          # Validate required Supabase secrets
          if [ -z "$SUPABASE_URL" ]; then
            echo "::error::SUPABASE_URL secret is not set! Frontend cannot connect to Supabase."
            exit 1
          fi
          if [ -z "$SUPABASE_KEY" ]; then
            echo "::error::SUPABASE_KEY secret is not set! Frontend cannot connect to Supabase."
            exit 1
          fi

          # Link to Vercel project
          vercel link --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed"; exit 1; }

          # Set environment variables via file (prevents secrets in logs)
          echo "ðŸ”§ Setting environment variables..."
          echo "$STAGING_API_URL" > /tmp/staging_api_url.txt
          vercel env add VITE_API_BASE_URL preview --force --yes --token="$VERCEL_TOKEN" --file=/tmp/staging_api_url.txt 2>/dev/null || true
          rm -f /tmp/staging_api_url.txt

          if [ -n "$GOOGLE_MAPS_API_KEY" ]; then
            echo "$GOOGLE_MAPS_API_KEY" > /tmp/google_maps_key.txt
            vercel env add VITE_GOOGLE_MAPS_API_KEY preview --force --yes --token="$VERCEL_TOKEN" --file=/tmp/google_maps_key.txt 2>/dev/null || true
            rm -f /tmp/google_maps_key.txt
          fi

          echo "$SUPABASE_URL" > /tmp/supabase_url.txt
          vercel env add VITE_SUPABASE_URL preview --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_url.txt 2>/dev/null || true
          rm -f /tmp/supabase_url.txt

          echo "$SUPABASE_KEY" > /tmp/supabase_key.txt
          vercel env add VITE_SUPABASE_ANON_KEY preview --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_key.txt 2>/dev/null || true
          rm -f /tmp/supabase_key.txt

          echo "âœ… Environment variables configured"

          # Deploy to Vercel with VITE_ env vars passed directly to the build
          BUILD_ENV_FLAGS=""
          BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_SUPABASE_URL=$SUPABASE_URL"
          BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_SUPABASE_ANON_KEY=$SUPABASE_KEY"
          if [ -n "$STAGING_API_URL" ]; then
            BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_API_BASE_URL=$STAGING_API_URL"
          fi
          if [ -n "$GOOGLE_MAPS_API_KEY" ]; then
            BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_GOOGLE_MAPS_API_KEY=$GOOGLE_MAPS_API_KEY"
          fi
          vercel deploy --yes --token="$VERCEL_TOKEN" $BUILD_ENV_FLAGS

      - name: Deploy Backend to Vercel (Staging)
        shell: bash
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}
          HAS_BACKEND_PROJECT: ${{ secrets.VERCEL_BACKEND_PROJECT_ID != '' }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          echo "ðŸš€ Deploying Backend to Vercel Staging..."

          if [ "$HAS_BACKEND_PROJECT" != "true" ]; then
            echo "::warning::VERCEL_BACKEND_PROJECT_ID secret is missing! Skipping backend deployment."
            exit 0
          fi

          # NOTE: Do NOT cd into backend/ here. The Vercel project settings
          # have Root Directory set to 'backend', so deploying from repo root is correct.
          # This is consistent with how the frontend is deployed.

          echo "ðŸ”— Linking Backend to Vercel..."
          vercel link --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed for backend"; exit 1; }

          echo "ðŸ”§ Setting environment variables..."
          echo "$SUPABASE_URL" > /tmp/supabase_url.txt
          vercel env add SUPABASE_URL preview --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_url.txt 2>/dev/null || true
          rm -f /tmp/supabase_url.txt

          echo "$SUPABASE_KEY" > /tmp/supabase_key.txt
          vercel env add SUPABASE_KEY preview --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_key.txt 2>/dev/null || true
          rm -f /tmp/supabase_key.txt

          if [ -n "$SUPABASE_SERVICE_ROLE_KEY" ]; then
            echo "$SUPABASE_SERVICE_ROLE_KEY" > /tmp/supabase_service_role_key.txt
            vercel env add SUPABASE_SERVICE_ROLE_KEY preview --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_service_role_key.txt 2>/dev/null || true
            rm -f /tmp/supabase_service_role_key.txt
          fi
          echo "âœ… Environment variables configured"

          vercel deploy --yes --token="$VERCEL_TOKEN"

      - name: Health Check
        if: inputs.skip_health_check != true
        env:
          STAGING_API_URL: ${{ secrets.STAGING_API_URL }}
          HAS_BACKEND_PROJECT: ${{ secrets.VERCEL_BACKEND_PROJECT_ID != '' }}
        run: |
          echo "ðŸ¥ Running health check..."

          echo "Waiting 10 seconds for service startup..."
          sleep 10

          MAX_RETRIES=20
          RETRY_DELAY=10
          BACKEND_OK=false

          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i of $MAX_RETRIES..."
            
            if curl -sf --max-time 10 "${STAGING_API_URL}/health/ready" > /dev/null 2>&1; then
              echo "âœ… Backend readiness check passed!"
              BACKEND_OK=true
              break
            else
              echo "Backend not ready yet, retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done

          if [ "$BACKEND_OK" != "true" ]; then
             if [ "$HAS_BACKEND_PROJECT" != "true" ]; then
               echo "âš ï¸ Backend check failed but VERCEL_BACKEND_PROJECT_ID was missing, so this is expected."
             else
               echo "âŒ Backend health check failed after $MAX_RETRIES attempts"
               exit 1
             fi
          fi

          echo "âœ… All health checks passed!"

      - name: Notify Deployment Result
        if: always()
        env:
          STAGING_FRONTEND_URL: ${{ secrets.STAGING_FRONTEND_URL }}
          STAGING_API_URL: ${{ secrets.STAGING_API_URL }}
          VERSION: ${{ needs.prepare.outputs.version }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          JOB_STATUS: ${{ job.status }}
        run: |
          if [ "$JOB_STATUS" == "success" ]; then
            echo "âœ… Staging deployment successful!"
            echo "ðŸ”— Frontend URL: ${STAGING_FRONTEND_URL}"
            echo "ðŸ”— Backend URL: ${STAGING_API_URL}"
            echo "ðŸ“¦ Version: ${VERSION}"
            COLOR_SLACK="good"
            COLOR_DISCORD=5763719
            TITLE="âœ… Staging Deployment Successful"
          else
            echo "âŒ Staging deployment failed!"
            COLOR_SLACK="danger"
            COLOR_DISCORD=15548997
            TITLE="âŒ Staging Deployment Failed"
          fi

          # Send Slack notification if configured
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -X POST "$SLACK_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -d "{
                \"text\": \"${TITLE}\",
                \"attachments\": [{
                  \"color\": \"${COLOR_SLACK}\",
                  \"fields\": [
                    {\"title\": \"Environment\", \"value\": \"Staging\", \"short\": true},
                    {\"title\": \"Version\", \"value\": \"${VERSION}\", \"short\": true},
                    {\"title\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                    {\"title\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"short\": false}
                  ]
                }]
              }" 2>/dev/null || echo "Slack notification failed"
          fi

          # Send Discord notification if configured
          if [ -n "$DISCORD_WEBHOOK_URL" ]; then
            curl -X POST "$DISCORD_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -d "{
                \"embeds\": [{
                  \"title\": \"${TITLE}\",
                  \"color\": ${COLOR_DISCORD},
                  \"fields\": [
                    {\"name\": \"Environment\", \"value\": \"Staging\", \"inline\": true},
                    {\"name\": \"Version\", \"value\": \"${VERSION}\", \"inline\": true},
                    {\"name\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                    {\"name\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}
                  ]
                }]
              }" 2>/dev/null || echo "Discord notification failed"
          fi

  # ============================================================================
  # DEPLOY TO PRODUCTION
  # ============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: prepare
    outputs:
      frontend_url: ${{ steps.deploy-frontend.outputs.deployment_url }}
    if: needs.prepare.outputs.environment == 'production'
    environment:
      name: production
      url: https://purrfect-spots.vercel.app
    permissions:
      contents: write # Needed for tagging releases
      packages: write
      deployments: write
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@8f152de45cc393bb48ce5d89d36b731f54556e65 # v4.4.2
        with:
          node-version: "20"

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Pre-deployment backup
        env:
          BACKUP_WEBHOOK_URL: ${{ secrets.BACKUP_WEBHOOK_URL }}
          BACKUP_API_KEY: ${{ secrets.BACKUP_API_KEY }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "ðŸ’¾ Creating pre-deployment backup..."
          if [ -n "$BACKUP_WEBHOOK_URL" ]; then
            curl -X POST "$BACKUP_WEBHOOK_URL" \
              -H "Authorization: Bearer $BACKUP_API_KEY" \
              -H "Content-Type: application/json" \
              -d "{\"type\": \"pre-deployment\", \"version\": \"${VERSION}\"}"
            echo "Backup triggered successfully"
          else
            echo "::warning::No backup webhook configured. Skipping backup."
          fi

      - name: Deploy Frontend to Vercel (Production)
        id: deploy-frontend
        shell: bash
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          PROD_API_URL: ${{ secrets.PROD_API_URL }}
          GOOGLE_MAPS_API_KEY: ${{ secrets.GOOGLE_MAPS_API_KEY }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          HAS_VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN != '' }}
          HAS_VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID != '' }}
          HAS_VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID != '' }}
        run: |
          echo "ðŸš€ Deploying Frontend to Vercel Production..."

          # Validate required env vars
          if [ "$HAS_VERCEL_TOKEN" != "true" ]; then
            echo "::error::VERCEL_TOKEN is not set"
            exit 1
          fi
          if [ "$HAS_VERCEL_ORG_ID" != "true" ]; then
            echo "::error::VERCEL_ORG_ID is not set"
            exit 1
          fi
          if [ "$HAS_VERCEL_PROJECT_ID" != "true" ]; then
             echo "::error::VERCEL_PROJECT_ID is not set"
             exit 1
          fi

          # NOTE: Do NOT cd into frontend/ here. The Vercel project settings
          # have Root Directory set to 'frontend', so deploying from repo root is correct.

          echo "ðŸ”— Linking to Vercel project..."
          vercel link --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed"; exit 1; }

          # Validate required Supabase secrets
          if [ -z "$SUPABASE_URL" ]; then
            echo "::error::SUPABASE_URL secret is not set! Frontend cannot connect to Supabase."
            exit 1
          fi
          if [ -z "$SUPABASE_KEY" ]; then
            echo "::error::SUPABASE_KEY secret is not set! Frontend cannot connect to Supabase."
            exit 1
          fi

          echo "ðŸ”§ Injecting environment variables..."
          echo "$PROD_API_URL" > /tmp/prod_api_url.txt
          vercel env add VITE_API_BASE_URL production --force --yes --token="$VERCEL_TOKEN" --file=/tmp/prod_api_url.txt 2>/dev/null || true
          rm -f /tmp/prod_api_url.txt

          if [ -n "$GOOGLE_MAPS_API_KEY" ]; then
            echo "$GOOGLE_MAPS_API_KEY" > /tmp/google_maps_key.txt
            vercel env add VITE_GOOGLE_MAPS_API_KEY production --force --yes --token="$VERCEL_TOKEN" --file=/tmp/google_maps_key.txt 2>/dev/null || true
            rm -f /tmp/google_maps_key.txt
          fi

          echo "$SUPABASE_URL" > /tmp/supabase_url.txt
          vercel env add VITE_SUPABASE_URL production --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_url.txt 2>/dev/null || true
          rm -f /tmp/supabase_url.txt

          echo "$SUPABASE_KEY" > /tmp/supabase_key.txt
          vercel env add VITE_SUPABASE_ANON_KEY production --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_key.txt 2>/dev/null || true
          rm -f /tmp/supabase_key.txt

          echo "âœ… Environment variables configured"

          echo "ðŸš€ Triggering Vercel Production Deployment..."
          # Pass VITE_ env vars directly to the build via --build-env to ensure
          # they are available during Vite's build process, even if vercel env add
          # hasn't fully propagated yet.
          BUILD_ENV_FLAGS=""
          BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_SUPABASE_URL=$SUPABASE_URL"
          BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_SUPABASE_ANON_KEY=$SUPABASE_KEY"
          if [ -n "$PROD_API_URL" ]; then
            BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_API_BASE_URL=$PROD_API_URL"
          fi
          if [ -n "$GOOGLE_MAPS_API_KEY" ]; then
            BUILD_ENV_FLAGS="$BUILD_ENV_FLAGS --build-env VITE_GOOGLE_MAPS_API_KEY=$GOOGLE_MAPS_API_KEY"
          fi
          DEPLOY_OUTPUT=$(vercel deploy --prod --yes --token="$VERCEL_TOKEN" $BUILD_ENV_FLAGS)
          DEPLOY_EXIT_CODE=$?

          if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
            echo "::error::Vercel deployment failed"
            echo "$DEPLOY_OUTPUT"
            exit $DEPLOY_EXIT_CODE
          fi

          deployment_url=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[a-zA-Z0-9.-]+\.vercel\.app' | head -1)

          if [ -z "$deployment_url" ]; then
            echo "::error::Deployment succeeded but no URL found"
            echo "$DEPLOY_OUTPUT"
            exit 1
          fi

          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
          echo "âœ… Deployed to: $deployment_url"

      - name: Deploy Backend to Vercel (Production)
        shell: bash
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}
          HAS_BACKEND_PROJECT: ${{ secrets.VERCEL_BACKEND_PROJECT_ID != '' }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: |
          echo "ðŸš€ Deploying Backend to Vercel Production..."

          if [ "$HAS_BACKEND_PROJECT" != "true" ]; then
            echo "::error::VERCEL_BACKEND_PROJECT_ID secret is missing! Cannot deploy backend to Production."
            exit 1
          fi

          if [ -z "$VERCEL_ORG_ID" ]; then
             echo "::error::VERCEL_ORG_ID is not set (Backend)"
             exit 1
          fi

          # NOTE: Do NOT cd into backend/ here. The Vercel project settings
          # have Root Directory set to 'backend', so deploying from repo root is correct.
          # This is consistent with how the frontend is deployed.

          echo "ðŸ”— Linking Backend to Vercel..."
          vercel link --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" || { echo "::error::Vercel link failed for backend"; exit 1; }

          echo "ðŸ”§ Injecting environment variables..."
          echo "$SUPABASE_URL" > /tmp/supabase_url.txt
          vercel env add SUPABASE_URL production --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_url.txt 2>/dev/null || true
          rm -f /tmp/supabase_url.txt

          echo "$SUPABASE_KEY" > /tmp/supabase_key.txt
          vercel env add SUPABASE_KEY production --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_key.txt 2>/dev/null || true
          rm -f /tmp/supabase_key.txt

          if [ -n "$SUPABASE_SERVICE_ROLE_KEY" ]; then
            echo "$SUPABASE_SERVICE_ROLE_KEY" > /tmp/supabase_service_role_key.txt
            vercel env add SUPABASE_SERVICE_ROLE_KEY production --force --yes --token="$VERCEL_TOKEN" --file=/tmp/supabase_service_role_key.txt 2>/dev/null || true
            rm -f /tmp/supabase_service_role_key.txt
          fi
          if [ -n "$JWT_SECRET" ]; then
            echo "$JWT_SECRET" > /tmp/jwt_secret.txt
            vercel env add JWT_SECRET production --force --yes --token="$VERCEL_TOKEN" --file=/tmp/jwt_secret.txt 2>/dev/null || true
            rm -f /tmp/jwt_secret.txt
          fi
          echo "âœ… Environment variables configured"

          echo "ðŸš€ Triggering Backend Deployment..."
          vercel deploy --prod --yes --token="$VERCEL_TOKEN"

      - name: Health Check
        if: inputs.skip_health_check != true
        env:
          PROD_API_URL: ${{ secrets.PROD_API_URL }}
          FRONTEND_URL: ${{ steps.deploy-frontend.outputs.deployment_url }}
          HAS_BACKEND_PROJECT: ${{ secrets.VERCEL_BACKEND_PROJECT_ID != '' }}
        run: |
          echo "ðŸ¥ Running production health check..."

          echo "Waiting 15 seconds for service startup..."
          sleep 15

          RETRY_DELAY=10
          BACKEND_OK=false
          FRONTEND_OK=false

          # â”€â”€ 1. Frontend Health Check â”€â”€
          echo ""
          echo "â”â”â” Frontend Health Check â”â”â”"
          if [ -z "$FRONTEND_URL" ]; then
            echo "âš ï¸ Frontend URL not available from deploy step output. Skipping."
            FRONTEND_OK=true
          else
            MAX_RETRIES_FE=10
            for i in $(seq 1 $MAX_RETRIES_FE); do
              echo "Frontend check attempt $i/$MAX_RETRIES_FE â†’ $FRONTEND_URL"
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 15 "$FRONTEND_URL" 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 400 ]; then
                echo "âœ… Frontend health check passed! (HTTP $HTTP_CODE)"
                FRONTEND_OK=true
                break
              fi
              echo "   â†³ HTTP $HTTP_CODE â€“ retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            done
            if [ "$FRONTEND_OK" != "true" ]; then
              echo "âŒ Frontend health check failed after $MAX_RETRIES_FE attempts"
            fi
          fi

          # â”€â”€ 2. Backend Health Check â”€â”€
          echo ""
          echo "â”â”â” Backend Health Check â”â”â”"
          if [ "$HAS_BACKEND_PROJECT" != "true" ]; then
            echo "âš ï¸ VERCEL_BACKEND_PROJECT_ID not configured. Skipping backend health check."
            BACKEND_OK=true
          elif [ -z "$PROD_API_URL" ]; then
            echo "âš ï¸ PROD_API_URL not set. Skipping backend health check."
            BACKEND_OK=true
          else
            # Try lightweight liveness probe first
            echo "Trying lightweight liveness probe..."
            LIVE_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${PROD_API_URL}/health/live" 2>/dev/null || echo "000")
            echo "   â†³ /health/live â†’ HTTP $LIVE_CODE"

            MAX_RETRIES_BE=20
            for i in $(seq 1 $MAX_RETRIES_BE); do
              echo "Backend readiness check attempt $i/$MAX_RETRIES_BE â†’ ${PROD_API_URL}/health/ready"
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 15 "${PROD_API_URL}/health/ready" 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "âœ… Backend readiness check passed! (HTTP $HTTP_CODE)"
                BACKEND_OK=true
                break
              fi
              echo "   â†³ HTTP $HTTP_CODE â€“ retrying in ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            done

            if [ "$BACKEND_OK" != "true" ]; then
              echo "âŒ Backend readiness check failed after $MAX_RETRIES_BE attempts"
              echo "â„¹ï¸ Trying to get diagnostic data..."
              curl -s --max-time 10 "${PROD_API_URL}/health/ready" 2>/dev/null || echo "(no response)"
            fi
          fi

          # â”€â”€ 3. Final Verdict â”€â”€
          echo ""
          echo "â”â”â” Health Check Summary â”â”â”"
          echo "Frontend: $([ "$FRONTEND_OK" = "true" ] && echo 'âœ… PASS' || echo 'âŒ FAIL')"
          echo "Backend:  $([ "$BACKEND_OK" = "true" ] && echo 'âœ… PASS' || echo 'âŒ FAIL')"

          if [ "$FRONTEND_OK" = "true" ] && [ "$BACKEND_OK" = "true" ]; then
            echo ""
            echo "âœ… All production health checks passed!"
          else
            echo ""
            echo "âŒ Production health check failed"
            echo "::error::Health check failed â€“ Frontend: $FRONTEND_OK, Backend: $BACKEND_OK"
            exit 1
          fi

      - name: Smoke Tests
        env:
          PROD_API_URL: ${{ secrets.PROD_API_URL }}
          FRONTEND_URL: ${{ steps.deploy-frontend.outputs.deployment_url }}
        run: |
          echo "ðŸ§ª Running smoke tests..."
          echo "Testing critical endpoints..."

          # Test health endpoint (jq is pre-installed on ubuntu-latest)
          curl -sf "${PROD_API_URL}/health/dependencies" | jq . || echo "Dependency health check"

          # Test public endpoints (no auth required)
          curl -sf "${PROD_API_URL}/api/v1/spots?limit=1" > /dev/null && echo "âœ… Spots API OK" || echo "::warning::Spots API check failed"

          # CORS Smoke Test
          if [ -n "$FRONTEND_URL" ]; then
            echo "Testing CORS connectivity from $FRONTEND_URL to ${PROD_API_URL}..."
            CORS_STATUS=$(curl -s -I -H "Origin: $FRONTEND_URL" -H "Access-Control-Request-Method: GET" "${PROD_API_URL}/health/ready" | grep -i "Access-Control-Allow-Origin" || echo "MISSING")
            
            if [[ "$CORS_STATUS" == *"MISSING"* ]]; then
               echo "::warning::âš ï¸ CORS headers missing! Frontend may not be able to talk to Backend."
            else
               echo "âœ… CORS Check Passed: $CORS_STATUS"
            fi
          else
            echo "::warning::Frontend URL not found, skipping CORS check."
          fi

          echo "âœ… Smoke tests completed!"

      - name: Create Release Tag
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "ðŸ·ï¸ Creating release tag..."

          TAG_NAME="release-${VERSION}"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create and push tag
          git tag -a "${TAG_NAME}" -m "Production release ${VERSION}"
          git push origin "${TAG_NAME}"

          # Create GitHub Release
          gh release create "${TAG_NAME}" \
            --title "Release ${VERSION}" \
            --notes "Automated production release

          - Version: ${VERSION}
          - Deployed by: ${{ github.actor }}
          - Commit: ${{ github.sha }}" \
            --latest

          echo "âœ… Release tag ${TAG_NAME} created and pushed"

      - name: Rollback on Failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_BACKEND_PROJECT_ID: ${{ secrets.VERCEL_BACKEND_PROJECT_ID }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          echo "ðŸ”„ Initiating rollback..."

          PREVIOUS_TAG=$(git describe --tags --abbrev=0 --exclude="release-${VERSION}" 2>/dev/null || echo "")

          if [ -n "$PREVIOUS_TAG" ]; then
            echo "Rolling back to $PREVIOUS_TAG"

            # Rollback frontend (use --project flag, don't cd)
            echo "Rolling back frontend..."
            vercel rollback --yes --token="$VERCEL_TOKEN" --project "$VERCEL_PROJECT_ID" || echo "::warning::Frontend rollback failed"

            # Rollback backend if configured
            if [ -n "$VERCEL_BACKEND_PROJECT_ID" ]; then
              echo "Rolling back backend..."
              vercel rollback --yes --token="$VERCEL_TOKEN" --project "$VERCEL_BACKEND_PROJECT_ID" || echo "::warning::Backend rollback failed"
            fi

            echo "âœ… Rollback completed"
          else
            echo "::warning::No previous tag found for rollback â€“ this appears to be the first deployment."
            echo "â„¹ï¸ Manual intervention may be needed. Check the deployment dashboard."
          fi

      - name: Notify Deployment Result
        if: always()
        env:
          FRONTEND_URL: ${{ steps.deploy-frontend.outputs.deployment_url }}
          VERSION: ${{ needs.prepare.outputs.version }}
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          JOB_STATUS: ${{ job.status }}
        run: |
          if [ "$JOB_STATUS" == "success" ]; then
            echo "âœ… Production deployment successful!"
            echo "ðŸ”— URL: ${FRONTEND_URL}"
            echo "ðŸ“¦ Version: ${VERSION}"
            COLOR_SLACK="good"
            COLOR_DISCORD=5763719
            TITLE="âœ… Production Deployment Successful"
          else
            echo "âŒ Production deployment failed!"
            echo "ðŸ”„ Rollback initiated automatically."
            COLOR_SLACK="danger"
            COLOR_DISCORD=15548997
            TITLE="âŒ Production Deployment Failed - Rollback Initiated"
          fi

          # Send Slack notification
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -X POST "$SLACK_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -d "{
                \"text\": \"${TITLE}\",
                \"attachments\": [{
                  \"color\": \"${COLOR_SLACK}\",
                  \"fields\": [
                    {\"title\": \"Environment\", \"value\": \"Production\", \"short\": true},
                    {\"title\": \"Version\", \"value\": \"${VERSION}\", \"short\": true},
                    {\"title\": \"URL\", \"value\": \"${FRONTEND_URL}\", \"short\": false},
                    {\"title\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"short\": true},
                    {\"title\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\", \"short\": false}
                  ]
                }]
              }" 2>/dev/null || echo "Slack notification failed"
          fi

          # Send Discord notification
          if [ -n "$DISCORD_WEBHOOK_URL" ]; then
            curl -X POST "$DISCORD_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -d "{
                \"embeds\": [{
                  \"title\": \"${TITLE}\",
                  \"color\": ${COLOR_DISCORD},
                  \"fields\": [
                    {\"name\": \"Environment\", \"value\": \"Production\", \"inline\": true},
                    {\"name\": \"Version\", \"value\": \"${VERSION}\", \"inline\": true},
                    {\"name\": \"URL\", \"value\": \"${FRONTEND_URL}\"},
                    {\"name\": \"Deployed by\", \"value\": \"${{ github.actor }}\", \"inline\": true},
                    {\"name\": \"Run\", \"value\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}
                  ]
                }]
              }" 2>/dev/null || echo "Discord notification failed"
          fi

  # ============================================================================
  # DEPLOYMENT SUMMARY
  # ============================================================================
  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [prepare, deploy-staging, deploy-production]
    if: always() && needs.prepare.outputs.should_deploy == 'true'
    steps:
      - name: Create deployment summary
        env:
          ENVIRONMENT: ${{ needs.prepare.outputs.environment }}
          VERSION: ${{ needs.prepare.outputs.version }}
          FRONTEND_URL: ${{ needs.deploy-production.outputs.frontend_url }}
          STAGING_RESULT: ${{ needs.deploy-staging.result }}
          PRODUCTION_RESULT: ${{ needs.deploy-production.result }}
          START_TIME: ${{ needs.prepare.outputs.start_time }}
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${ENVIRONMENT} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${VERSION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | ${FRONTEND_URL} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ github.event_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Actor | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${ENVIRONMENT}" == "staging" ]; then
            echo "### Staging Deployment" >> $GITHUB_STEP_SUMMARY
            STATUS="âŒ Failed"
            [ "${STAGING_RESULT}" == "success" ] && STATUS="âœ… Success"
            [ "${STAGING_RESULT}" == "skipped" ] && STATUS="â­ï¸ Skipped"
            echo "| Status | ${STATUS} |" >> $GITHUB_STEP_SUMMARY
          elif [ "${ENVIRONMENT}" == "production" ]; then
            echo "### Production Deployment" >> $GITHUB_STEP_SUMMARY
            STATUS="âŒ Failed"
            [ "${PRODUCTION_RESULT}" == "success" ] && STATUS="âœ… Success"
            [ "${PRODUCTION_RESULT}" == "skipped" ] && STATUS="â­ï¸ Skipped"
            echo "| Status | ${STATUS} |" >> $GITHUB_STEP_SUMMARY
            echo "| URL | ${FRONTEND_URL} |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Deployment Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run ID**: \`${{ github.run_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ github.server_url }}/${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Calculate deployment duration
          if [ -n "$START_TIME" ] && [ "$START_TIME" != "null" ]; then
            END_TIME=$(date +%s)
            DURATION=$((END_TIME - START_TIME))
            if [ $DURATION -gt 0 ]; then
              MINUTES=$((DURATION / 60))
              SECONDS=$((DURATION % 60))
              echo "- **Deployment Duration**: ${MINUTES}m ${SECONDS}s" >> $GITHUB_STEP_SUMMARY
            fi
          fi
